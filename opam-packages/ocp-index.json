{
  "versions": {
    "1.1.1": {
      "version": "1.1.1", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.1.tar.gz", 
        "checksum": "b0292b2bb49959d84b17d3718331e658", 
        "files": [
          {
            "content": "diff --git a/src/browserMain.ml b/src/browserMain.ml\nindex 3b277b7..6a201a7 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -16,7 +16,7 @@ let rec eq l1 l2 = match l1, l2 with\n let kind_to_tag, tag_to_style, register_ressource =\n   let h = Hashtbl.create 11 in\n   let kind_to_tag = function\n-    | LibIndex.Type -> \"Type\"\n+    | LibIndex.Type | OpenType -> \"Type\"\n     | Value -> \"Value\"\n     | Exception -> \"Exception\"\n     | Field _  -> \"Field\"\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex 1493262..772704e 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -82,8 +82,7 @@ end = struct\n   let ident path f ch =\n     let modname =\n       let s = Filename.basename (Filename.chop_extension f) in\n-      s.[0] <- Char.uppercase s.[0];\n-      s\n+      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex aca5bff..139fa5b 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -131,8 +131,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -205,6 +205,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -212,11 +213,15 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n (* -- end -- *)\n@@ -224,19 +229,16 @@ let qualify_ty_in_sig_item (parents:parents) =\n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n-  (* Sadly the Types tree doesn't contain locations for those. This means we\n-     won't associate comments easily either (todo...) *)\n-  | Types.Sig_module _\n-  | Types.Sig_modtype _\n-  | Types.Sig_class _\n-  | Types.Sig_class_type _\n-    -> Location.none\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_loc\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_loc\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_loc\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_loc\n \n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -246,7 +248,8 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n@@ -255,20 +258,25 @@ let kind_of_sig_item = function\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -279,25 +287,29 @@ let trie_of_type_decl ?comments info ty_decl =\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -353,19 +365,21 @@ let rec trie_of_sig_item\n   in\n   (* ignore functor arguments *)\n   let rec sig_item_contents = function\n-    | Types.Sig_module (id, Types.Mty_functor (_,_,s), is_rec) ->\n-        sig_item_contents (Types.Sig_module (id, s, is_rec))\n+    | Types.Sig_module\n+        (id, ({Types.md_type = Types.Mty_functor (_,_,s)} as funct), is_rec) ->\n+        let funct = {funct with Types.md_type = s} in\n+        sig_item_contents (Types.Sig_module (id, funct, is_rec))\n     | Types.Sig_modtype\n-        (id, Types.Modtype_manifest (Types.Mty_functor (_,_,s))) ->\n-        sig_item_contents\n-          (Types.Sig_modtype (id, Types.Modtype_manifest s))\n+        (id, ({Types.mtd_type = Some (Types.Mty_functor (_,_,s))} as funct)) ->\n+        let funct = {funct with Types.mtd_type = Some s} in\n+        sig_item_contents (Types.Sig_modtype (id, funct))\n     | si -> si\n   in\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item_contents sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let children_comments = lazy (\n@@ -385,8 +399,12 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_)\n-    | Types.Sig_modtype (_,Types.Modtype_manifest (Types.Mty_ident sig_ident)) ->\n+    | Types.Sig_module (_,{ Types.md_type =\n+                              Types.Mty_ident sig_ident\n+                            | Types.Mty_alias sig_ident},_)\n+    | Types.Sig_modtype (_,{ Types.mtd_type =\n+                               Some ( Types.Mty_ident sig_ident\n+                                    | Types.Mty_alias sig_ident) }) ->\n         let sig_path =\n           let rec get_path = function\n             | Path.Pident id -> [id.Ident.name]\n@@ -422,22 +440,26 @@ let rec trie_of_sig_item\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\ndiff --git a/src/indexMisc.ml b/src/indexMisc.ml\nindex f3231ce..929d431 100644\n--- a/src/indexMisc.ml\n+++ b/src/indexMisc.ml\n@@ -57,12 +57,12 @@ let string_to_key s =\n \n let key_to_string l =\n   let rec aux n = function\n-    | [] -> String.create n\n+    | [] -> Bytes.create n\n     | c::r ->\n         let s = aux (n+1) r in\n-        s.[n] <- if c = dot then '.' else c; s\n+        Bytes.set s n (if c = dot then '.' else c); s\n   in\n-  aux 0 l\n+  Bytes.to_string (aux 0 l)\n \n let modpath_to_key ?(enddot=true) path =\n   List.fold_right (fun p acc ->\n@@ -70,15 +70,12 @@ let modpath_to_key ?(enddot=true) path =\n       string_to_key p @ acc) path []\n \n let key_to_modpath l =\n-  let rec aux n = function\n-    | [] -> if n > 0 then [String.create n] else []\n-    | '\\000'::r -> String.create n :: aux 0 r\n-    | c::r ->\n-        match aux (n+1) r with\n-        | s::_ as p -> s.[n] <- c; p\n-        | [] -> assert false\n+  let rec aux acc1 acc2 = function\n+    | '\\000'::r -> aux [] (acc1::acc2) r\n+    | c::r -> aux (c::acc1) acc2 r\n+    | [] -> if acc1 = [] then acc2 else acc1::acc2\n   in\n-  aux 0 l\n+  List.rev_map (fun l -> key_to_string (List.rev l)) (aux [] [] l)\n \n let modpath_to_string path = String.concat \".\" path\n \ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex d5b5d18..1854bf5 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex d95ec8b..9ea17db 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -154,20 +155,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl ty\n+    | Osig_type ({ otype_type },_) ->\n+        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 5f493bf..0fe7729 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex bbd1f9a..223e0c0 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex 8572f90..e48f78b 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -44,7 +44,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/ocp-index.ocp b/src/ocp-index.ocp\nindex d7f0fc9..47b1a55 100644\n--- a/src/ocp-index.ocp\n+++ b/src/ocp-index.ocp\n@@ -1,4 +1,5 @@\n-comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n+comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" \"-safe-string\" ]\n+link += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n \n begin library \"ocp-index-lib\"\n   sort = false\n", 
            "name": "ocaml.4.02.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.1"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.6", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.03.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.1.0": {
      "version": "1.1.0", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.0.tar.gz", 
        "checksum": "86906393d00840c41df3a2a1355ce861", 
        "files": [
          {
            "content": "From f50b1a488e25ae3fb9125d2a739b614adfbad6a6 Mon Sep 17 00:00:00 2001\nFrom: Peter Zotov <whitequark@whitequark.org>\nDate: Mon, 12 May 2014 20:18:37 +0400\nSubject: [PATCH] Update for 4.02.\n\n---\n src/browserMain.ml     |  2 +-\n src/indexBuild.ml      | 79 +++++++++++++++++++++++++++++++-------------------\n src/indexOptions.ml    |  2 +-\n src/indexOut.ml        | 13 +++++----\n src/indexPredefined.ml | 27 ++++++++++++-----\n src/indexTypes.ml      |  2 +-\n src/libIndex.mli       |  2 +-\n 7 files changed, 79 insertions(+), 48 deletions(-)\n\ndiff --git a/src/browserMain.ml b/src/browserMain.ml\nindex f34f6d5..fa5c8d0 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -186,7 +186,7 @@ let interactive opts () =\n           LibIndex.Format.no_color\n         else\n           let attr = function\n-            | LibIndex.Type -> Curses.WA.color_pair 6\n+            | LibIndex.Type | LibIndex.OpenType -> Curses.WA.color_pair 6\n             | LibIndex.Value -> Curses.WA.bold\n             | LibIndex.Exception -> Curses.WA.color_pair 3\n             | LibIndex.Field _ | LibIndex.Variant _ -> Curses.WA.color_pair 4\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex 3eddb5e..c25fdf2 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -123,8 +123,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -195,6 +195,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -202,17 +203,21 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n   (* Sadly the Types tree doesn't contain locations for those. This means we\n      won't associate comments easily either (todo...) *)\n   | Types.Sig_module _\n@@ -224,7 +229,7 @@ let loc_of_sig_item = function\n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -234,7 +239,8 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n@@ -243,20 +249,25 @@ let kind_of_sig_item = function\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -267,25 +278,29 @@ let trie_of_type_decl ?comments info ty_decl =\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -313,7 +328,7 @@ let locate_impl cmt path name kind =\n               sign\n           in\n           match modul with\n-          | Types.Sig_module (_,Types.Mty_signature sign,_) ->\n+          | Types.Sig_module (_, {Types.md_type = Types.Mty_signature sign},_) ->\n               find_item path sign\n           | _ -> raise Not_found\n     in\n@@ -370,8 +385,8 @@ let rec trie_of_sig_item\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let rec children_comments = lazy (\n@@ -392,7 +407,7 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_) ->\n+    | Types.Sig_module (_,{ Types.md_type = Types.Mty_ident sig_ident },_) ->\n         let sig_path =\n           let rec get_path = function\n             | Path.Pident id -> [id.Ident.name]\n@@ -419,22 +434,26 @@ let rec trie_of_sig_item\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex a800e9f..808fe25 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex d95ec8b..9ea17db 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -154,20 +155,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl ty\n+    | Osig_type ({ otype_type },_) ->\n+        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 5f493bf..0fe7729 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex 252386b..e094317 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex 9e7efa8..b826cf7 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -40,7 +40,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\n-- \n2.0.1\n\n", 
            "name": "0001-Update-for-4.02.patch"
          }, 
          {
            "content": "diff --git a/src/browserMain.ml b/src/browserMain.ml\nindex 3b277b7..6a201a7 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -16,7 +16,7 @@ let rec eq l1 l2 = match l1, l2 with\n let kind_to_tag, tag_to_style, register_ressource =\n   let h = Hashtbl.create 11 in\n   let kind_to_tag = function\n-    | LibIndex.Type -> \"Type\"\n+    | LibIndex.Type | OpenType -> \"Type\"\n     | Value -> \"Value\"\n     | Exception -> \"Exception\"\n     | Field _  -> \"Field\"\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex 4dae5a6..514ca71 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -82,8 +82,7 @@ end = struct\n   let ident path f ch =\n     let modname =\n       let s = Filename.basename (Filename.chop_extension f) in\n-      s.[0] <- Char.uppercase s.[0];\n-      s\n+      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex 9c14706..dca601b 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -123,8 +123,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -197,6 +197,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -204,11 +205,15 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n (* -- end -- *)\n@@ -216,19 +221,16 @@ let qualify_ty_in_sig_item (parents:parents) =\n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n-  (* Sadly the Types tree doesn't contain locations for those. This means we\n-     won't associate comments easily either (todo...) *)\n-  | Types.Sig_module _\n-  | Types.Sig_modtype _\n-  | Types.Sig_class _\n-  | Types.Sig_class_type _\n-    -> Location.none\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_loc\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_loc\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_loc\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_loc\n \n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -238,7 +240,8 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n@@ -247,20 +250,25 @@ let kind_of_sig_item = function\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -271,25 +279,29 @@ let trie_of_type_decl ?comments info ty_decl =\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -338,19 +350,21 @@ let rec trie_of_sig_item\n   in\n   (* ignore functor arguments *)\n   let rec sig_item_contents = function\n-    | Types.Sig_module (id, Types.Mty_functor (_,_,s), is_rec) ->\n-        sig_item_contents (Types.Sig_module (id, s, is_rec))\n+    | Types.Sig_module\n+        (id, ({Types.md_type = Types.Mty_functor (_,_,s)} as funct), is_rec) ->\n+        let funct = {funct with Types.md_type = s} in\n+        sig_item_contents (Types.Sig_module (id, funct, is_rec))\n     | Types.Sig_modtype\n-        (id, Types.Modtype_manifest (Types.Mty_functor (_,_,s))) ->\n-        sig_item_contents\n-          (Types.Sig_modtype (id, Types.Modtype_manifest s))\n+        (id, ({Types.mtd_type = Some (Types.Mty_functor (_,_,s))} as funct)) ->\n+        let funct = {funct with Types.mtd_type = Some s} in\n+        sig_item_contents (Types.Sig_modtype (id, funct))\n     | si -> si\n   in\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item_contents sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let children_comments = lazy (\n@@ -370,8 +384,12 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_)\n-    | Types.Sig_modtype (_,Types.Modtype_manifest (Types.Mty_ident sig_ident)) ->\n+    | Types.Sig_module (_,{ Types.md_type =\n+                              Types.Mty_ident sig_ident\n+                            | Types.Mty_alias sig_ident},_)\n+    | Types.Sig_modtype (_,{ Types.mtd_type =\n+                               Some ( Types.Mty_ident sig_ident\n+                                    | Types.Mty_alias sig_ident) }) ->\n         let sig_path =\n           let rec get_path = function\n             | Path.Pident id -> [id.Ident.name]\n@@ -407,22 +425,26 @@ let rec trie_of_sig_item\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\ndiff --git a/src/indexMisc.ml b/src/indexMisc.ml\nindex 2c171db..308af66 100644\n--- a/src/indexMisc.ml\n+++ b/src/indexMisc.ml\n@@ -52,12 +52,12 @@ let string_to_key s =\n \n let key_to_string l =\n   let rec aux n = function\n-    | [] -> String.create n\n+    | [] -> Bytes.create n\n     | c::r ->\n         let s = aux (n+1) r in\n-        s.[n] <- if c = dot then '.' else c; s\n+        Bytes.set s n (if c = dot then '.' else c); s\n   in\n-  aux 0 l\n+  Bytes.to_string (aux 0 l)\n \n let modpath_to_key ?(enddot=true) path =\n   List.fold_right (fun p acc ->\n@@ -65,15 +65,12 @@ let modpath_to_key ?(enddot=true) path =\n       string_to_key p @ acc) path []\n \n let key_to_modpath l =\n-  let rec aux n = function\n-    | [] -> if n > 0 then [String.create n] else []\n-    | '\\000'::r -> String.create n :: aux 0 r\n-    | c::r ->\n-        match aux (n+1) r with\n-        | s::_ as p -> s.[n] <- c; p\n-        | [] -> assert false\n+  let rec aux acc1 acc2 = function\n+    | '\\000'::r -> aux [] (acc1::acc2) r\n+    | c::r -> aux (c::acc1) acc2 r\n+    | [] -> if acc1 = [] then acc2 else acc1::acc2\n   in\n-  aux 0 l\n+  List.rev_map (fun l -> key_to_string (List.rev l)) (aux [] [] l)\n \n let modpath_to_string path = String.concat \".\" path\n \ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex d5b5d18..1854bf5 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex d95ec8b..9ea17db 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -154,20 +155,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl ty\n+    | Osig_type ({ otype_type },_) ->\n+        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 5f493bf..0fe7729 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex 252386b..e094317 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex 9e7efa8..b826cf7 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -40,7 +40,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/ocp-index.ocp b/src/ocp-index.ocp\nindex d7f0fc9..47b1a55 100644\n--- a/src/ocp-index.ocp\n+++ b/src/ocp-index.ocp\n@@ -1,4 +1,5 @@\n-comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n+comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" \"-safe-string\" ]\n+link += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n \n begin library \"ocp-index-lib\"\n   sort = false\n", 
            "name": "ocaml.4.02.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.0"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": ">= 1.7.0", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.6", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.01.0 < 4.03.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.1.3": {
      "version": "1.1.3", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.3.tar.gz", 
        "checksum": "9f316811b8336cc57a8f245dd3becc3e", 
        "files": [
          {
            "content": "diff --git a/opam b/opam\nindex 3a9a458..7c58305 100644\n--- a/opam\n+++ b/opam\n@@ -13,7 +13,7 @@ tags: [\n   \"org:ocamlpro\"\n   \"org:typerex\"\n ]\n-dev-repo: \"https://github.com/OCamlPro/ocp-index.git\"\n+dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.02\"\n build: [\n   [\"./configure\" \"--prefix\" prefix]\n   [make]\n@@ -26,7 +26,7 @@ depends: [\n ]\n depopts: \"lambda-term\"\n conflicts: \"lambda-term\" {< \"1.7\"}\n-available: [ocaml-version >= \"4.01.0\" & ocaml-version < \"4.02\"]\n+available: [ocaml-version >= \"4.02.0\" & ocaml-version < \"4.03\"]\n messages: \"For ocp-browser, please also install package lambda-term\" {! lambda-term:installed}\n post-messages:\n   \"This package requires additional configuration for use in editors. Either install package 'user-setup', or manually:\ndiff --git a/src/browserMain.ml b/src/browserMain.ml\nindex 2bd5191..49065a9 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -16,7 +16,7 @@ let rec eq l1 l2 = match l1, l2 with\n let kind_to_tag, tag_to_style, register_ressource =\n   let h = Hashtbl.create 11 in\n   let kind_to_tag = function\n-    | LibIndex.Type -> \"Type\"\n+    | LibIndex.Type | OpenType -> \"Type\"\n     | Value -> \"Value\"\n     | Exception -> \"Exception\"\n     | Field _  -> \"Field\"\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex a37cc77..88b2fa9 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -85,8 +85,7 @@ end = struct\n         Filename.basename\n           (try Filename.chop_extension f with Invalid_argument _ -> f)\n       in\n-      s.[0] <- Char.uppercase s.[0];\n-      s\n+      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex ac77d03..cf914c0 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -36,13 +36,13 @@ let orig_file_name = function\n   | Cmt f | Cmti f | Cmi f -> f\n \n let equal_kind k1 k2 = match k1,k2 with\n-  | Type,Type | Value,Value | Exception,Exception\n+  | Type,Type | Value,Value | Exception,Exception | OpenType,OpenType\n   | Field _,Field _ | Variant _,Variant _ | Method _,Method _\n   | Module,Module | ModuleType,ModuleType\n   | Class,Class | ClassType,ClassType\n   | Keyword,Keyword ->\n       true\n-  | Type,_ | Value,_ | Exception,_\n+  | Type,_ | Value,_ | Exception,_ | OpenType,_\n   | Field _,_ | Variant _,_ | Method _,_\n   | Module,_ | ModuleType,_\n   | Class,_ | ClassType,_\n@@ -146,8 +146,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -220,6 +220,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -227,11 +228,15 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n (* -- end -- *)\n@@ -239,19 +244,16 @@ let qualify_ty_in_sig_item (parents:parents) =\n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n-  (* Sadly the Types tree doesn't contain locations for those. This means we\n-     won't associate comments easily either (todo...) *)\n-  | Types.Sig_module _\n-  | Types.Sig_modtype _\n-  | Types.Sig_class _\n-  | Types.Sig_class_type _\n-    -> Location.none\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_loc\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_loc\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_loc\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_loc\n \n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -261,67 +263,129 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n   | Types.Sig_class_type _ -> ClassType\n \n+let attrs_of_sig_item = function\n+  | Types.Sig_value (_,descr) -> descr.Types.val_attributes\n+  | Types.Sig_type (_,descr,_) -> descr.Types.type_attributes\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_attributes\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_attributes\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_attributes\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_attributes\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_attributes\n+\n+let doc_of_attributes attrs =\n+  let doc_loc_id = \"ocaml.doc\" in (* not exported ! *)\n+  let open Parsetree in\n+  match List.find (fun ({Location.txt},_) -> txt = doc_loc_id) attrs with\n+  | _, PStr [{pstr_desc = Pstr_eval ({pexp_desc},_)}] ->\n+      (match pexp_desc with\n+       | Pexp_constant (Const_string (s,_)) -> Some s\n+       | _ -> debug \"Unexpected ocaml.doc docstring format\"; None)\n+  | _ -> None\n+  | exception Not_found -> None\n+\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type; ld_attributes } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          let doc = doc_of_attributes ld_attributes in\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n-            doc = lazy None;\n+            doc = lazy doc;\n             file = info.file;\n           } ())\n         fields,\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args; cd_attributes } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          let doc = doc_of_attributes cd_attributes in\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n-            doc = lazy None;\n+            doc = lazy doc;\n             file = info.file;\n           } ())\n         variants,\n       comments\n \n+(** Implements looking up a module path in the parents list *)\n+let lookup_parents (parents:parents) path sig_path =\n+  let sig_key, path_key = match sig_path with\n+    | hd::tl ->\n+        modpath_to_key [hd], modpath_to_key tl\n+    | [] -> assert false\n+  in\n+  let rec lookup = function\n+    | [] ->\n+        if debug_enabled then\n+          debug \"WARN: Module or sig reference %s not found a %s\\n\"\n+            (modpath_to_string sig_path)\n+            (modpath_to_string path);\n+        Trie.empty\n+    | (parentpath, lazy t) :: parents ->\n+        let s = Trie.sub t sig_key in\n+        if s = Trie.empty then lookup parents else\n+          let s = Trie.sub s path_key in\n+          let rewrite_path =\n+            fix_path_prefix (List.length parentpath + List.length sig_path) path\n+          in\n+          Trie.map (fun _k v -> rewrite_path v) s\n+  in\n+  lookup parents\n+\n+let rec path_of_ocaml = function\n+  | Path.Pident id -> [id.Ident.name]\n+  | Path.Pdot (path, s, _) -> path_of_ocaml path @ [s]\n+  | Path.Papply (p1, _p2) -> path_of_ocaml p1\n+\n let rec trie_of_sig_item\n     ?comments implloc_trie (parents:parents) (orig_file:orig_file) path\n     sig_item next\n@@ -333,9 +397,10 @@ let rec trie_of_sig_item\n     | Some n -> loc_of_sig_item n\n   in\n   let doc, comments =\n-    match comments with\n-    | None -> lazy None, None\n-    | Some comments ->\n+    match doc_of_attributes (attrs_of_sig_item sig_item), comments with\n+    | Some s, _ -> lazy (Some s), comments\n+    | None, None -> lazy None, None\n+    | None, Some comments ->\n         let assoc = lazy (\n           associate_comment (Lazy.force comments) loc nextloc\n         ) in\n@@ -368,19 +433,21 @@ let rec trie_of_sig_item\n   in\n   (* ignore functor arguments *)\n   let rec sig_item_contents = function\n-    | Types.Sig_module (id, Types.Mty_functor (_,_,s), is_rec) ->\n-        sig_item_contents (Types.Sig_module (id, s, is_rec))\n+    | Types.Sig_module\n+        (id, ({Types.md_type = Types.Mty_functor (_,_,s)} as funct), is_rec) ->\n+        let funct = {funct with Types.md_type = s} in\n+        sig_item_contents (Types.Sig_module (id, funct, is_rec))\n     | Types.Sig_modtype\n-        (id, Types.Modtype_manifest (Types.Mty_functor (_,_,s))) ->\n-        sig_item_contents\n-          (Types.Sig_modtype (id, Types.Modtype_manifest s))\n+        (id, ({Types.mtd_type = Some (Types.Mty_functor (_,_,s))} as funct)) ->\n+        let funct = {funct with Types.mtd_type = Some s} in\n+        sig_item_contents (Types.Sig_modtype (id, funct))\n     | si -> si\n   in\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item_contents sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let children_comments = lazy (\n@@ -400,64 +467,43 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_)\n-    | Types.Sig_modtype (_,Types.Modtype_manifest (Types.Mty_ident sig_ident)) ->\n-        let sig_path =\n-          let rec get_path = function\n-            | Path.Pident id -> [id.Ident.name]\n-            | Path.Pdot (path, s, _) -> get_path path @ [s]\n-            | Path.Papply (p1, _p2) -> get_path p1\n-          in\n-          get_path sig_ident\n-        in\n-        let sig_key, path_key = match sig_path with\n-          | hd::tl ->\n-              modpath_to_key [hd], modpath_to_key tl\n-          | [] -> assert false\n-        in\n-        let rec lookup = function\n-          | [] ->\n-              if debug_enabled then\n-                debug \"WARN: Module or sig reference %s not found a %s\\n\"\n-                  (modpath_to_string sig_path)\n-                  (modpath_to_string (path@[id.Ident.name]));\n-              Trie.empty\n-          | (parentpath, lazy t) :: parents ->\n-              let s = Trie.sub t sig_key in\n-              if s = Trie.empty then lookup parents else\n-                let s = Trie.sub s path_key in\n-                let rewrite_path =\n-                  fix_path_prefix\n-                    (List.length parentpath + List.length sig_path)\n-                    (path @ [id.Ident.name])\n-                in\n-                Trie.map (fun _k v -> rewrite_path v) s\n-        in\n+    | Types.Sig_module (_,{ Types.md_type =\n+                              Types.Mty_ident sig_ident\n+                            | Types.Mty_alias sig_ident},_)\n+    | Types.Sig_modtype (_,{ Types.mtd_type =\n+                               Some ( Types.Mty_ident sig_ident\n+                                    | Types.Mty_alias sig_ident) }) ->\n+        let sig_path = path_of_ocaml sig_ident in\n         let children = lazy (\n           (* Only keep the children, don't override the module reference *)\n-          Trie.graft_lazy Trie.empty [] (lazy (lookup parents))\n+          Trie.graft_lazy Trie.empty []\n+            (lazy (lookup_parents parents (path@[id.Ident.name]) sig_path))\n         ) in\n         children, comments\n     | Types.Sig_class (id,{Types.cty_type=cty},_)\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\n@@ -486,6 +532,139 @@ let rec trie_of_sig_item\n     :: siblings,\n     comments\n \n+\n+(* These four functions go through the typedtree to extract includes *)\n+let rec lookup_trie_of_module_expr parents t path = function\n+  | Typedtree.Tmod_ident (incpath,{ Location.txt = _lid}) ->\n+      let incpath = path_of_ocaml incpath in\n+      debug \"Including %s impl at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+      let parents = (path, lazy t) :: parents in\n+      let sub = lookup_parents parents path incpath in\n+      overriding_merge t sub\n+  | Typedtree.Tmod_constraint (e,_,_,_)\n+  (* | Typedtree.Tmod_apply (e,_,_) *) ->\n+      lookup_trie_of_module_expr parents t path e.mod_desc\n+  | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                          { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                     | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+      let t = lookup_trie_of_module_expr parents t path f.Typedtree.mod_desc in\n+      debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+      let functor_arg = lazy (lookup_parents parents (path_of_ocaml arg) path) in\n+      Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg\n+  | _ -> t\n+let rec extract_includes_from_submodule_sig parents t path name = function\n+  | Typedtree.Tmty_signature sign ->\n+      let path = path @ [name] in\n+      let sub_includes = lazy (\n+        get_includes_sig ((path, lazy t) :: parents)\n+          (Trie.sub t (modpath_to_key [name])) path sign\n+      ) in\n+      Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+  | Typedtree.Tmty_functor (_,_,_,e)\n+  | Typedtree.Tmty_with (e,_) ->\n+      extract_includes_from_submodule_sig parents t path name e.Typedtree.mty_desc\n+  | _ -> t\n+and get_includes_impl parents t path ttree_struct =\n+  let rec extract_submodule_impl t name = function\n+    | Typedtree.Tmod_structure str ->\n+        let path = path @ [name] in\n+        let sub_includes = lazy (\n+          get_includes_impl ((path, lazy t) :: parents)\n+            (Trie.sub t (modpath_to_key [name])) path str\n+        ) in\n+        Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+    (* | Typedtree.Tmod_functor (arg_id,_,arg_t,e) *)\n+    | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                            { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                       | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+        debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+        let functor_arg = lazy (\n+          lookup_parents\n+            ((path, lazy t)::parents) (path_of_ocaml arg) (path@[name])\n+        ) in\n+        extract_submodule_impl\n+          (Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg)\n+          name f.Typedtree.mod_desc\n+    | Typedtree.Tmod_functor (_,_,_,e)\n+    | Typedtree.Tmod_constraint (e,_,_,_) ->\n+        extract_submodule_impl t name e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t struc_item ->\n+      match struc_item.Typedtree.str_desc with\n+      | Typedtree.Tstr_include\n+          { Typedtree.incl_mod = { Typedtree.mod_desc = e }} ->\n+          lookup_trie_of_module_expr parents t path e\n+      | Typedtree.Tstr_open\n+          { Typedtree.open_path = p } ->\n+          let sub = lookup_parents ((path, lazy t) :: parents) path (path_of_ocaml p) in\n+          overriding_merge t sub\n+      | Typedtree.Tstr_module\n+          { Typedtree.mb_id = id; mb_expr = { Typedtree.mod_desc } } ->\n+          extract_submodule_impl t id.Ident.name mod_desc\n+      | Typedtree.Tstr_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.mb_id; mb_expr = { Typedtree.mod_desc } } ->\n+               extract_submodule_impl t mb_id.Ident.name mod_desc)\n+            t l\n+      | Typedtree.Tstr_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc = e } } ->\n+          extract_includes_from_submodule_sig parents t path id.Ident.name e\n+      | _ -> t)\n+    t ttree_struct.Typedtree.str_items\n+and get_includes_sig parents t path ttree_sig =\n+  let rec extract_includes t = function\n+    | Typedtree.Tmty_ident (incpath,_) ->\n+        let incpath = path_of_ocaml incpath in\n+        debug \"Including %s sig at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+        let parents = (path, lazy t) :: parents in\n+        let sub = lookup_parents parents path incpath in\n+        overriding_merge t sub\n+    | Typedtree.Tmty_with (e,_) ->\n+        extract_includes t e.Typedtree.mty_desc\n+    | Typedtree.Tmty_typeof e ->\n+        lookup_trie_of_module_expr parents t path\n+          e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t sig_item ->\n+      match sig_item.Typedtree.sig_desc with\n+      | Typedtree.Tsig_include\n+          { Typedtree.incl_mod = { Typedtree.mty_desc = e }} ->\n+          extract_includes t e\n+      | Typedtree.Tsig_module\n+          { Typedtree.md_id = id ; md_type = { Typedtree.mty_desc } }\n+      | Typedtree.Tsig_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc } } ->\n+          extract_includes_from_submodule_sig parents t path\n+            id.Ident.name mty_desc\n+      | Typedtree.Tsig_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.md_id; md_type = { Typedtree.mty_desc } } ->\n+               extract_includes_from_submodule_sig parents t path\n+                 md_id.Ident.name mty_desc)\n+            t l\n+      | _ -> t)\n+    t ttree_sig.Typedtree.sig_items\n+\n+let add_locs ~locs t =\n+  Trie.map (fun path info ->\n+      let loc_info = lazy (\n+        List.find (has_kind info.kind) (Trie.find_all locs path)\n+      ) in\n+      let lookup fld none =\n+        let loc = Lazy.force (fld info) in\n+        if loc = none\n+        then try Lazy.force (fld (Lazy.force loc_info)) with Not_found -> none\n+        else loc\n+      in\n+      { info with\n+        loc_sig = lazy (lookup (fun i -> i.loc_sig) Location.none);\n+        loc_impl = lazy (lookup (fun i -> i.loc_impl) Location.none);\n+        doc = lazy (lookup (fun i -> i.doc) None);\n+      }\n+    ) t\n+\n (* Can work in a subtree (t doesn't have to be the root) *)\n let qualify_type_idents parents t =\n   let qualify _key id =\n@@ -524,6 +703,14 @@ let cmt_sign cmt_contents =\n     -> Some sign\n   | _ -> None\n \n+let cmt_includes parents t path cmt_contents =\n+  match cmt_contents.Cmt_format.cmt_annots with\n+  | Cmt_format.Implementation impl ->\n+      get_includes_impl parents t path impl\n+  | Cmt_format.Interface sign ->\n+      get_includes_sig parents t path sign\n+  | _ -> Trie.empty\n+\n let protect_read reader f =\n   try reader f with\n   | Cmt_format.Error _ | Cmi_format.Error _ ->\n@@ -539,7 +726,7 @@ let lookup_loc_impl orig_file =\n       if not (Sys.file_exists cmt) then None else Some cmt\n \n let load_loc_impl parents filename cmt_contents =\n-  debug \"Registering %s (for implementation locations)...\" filename;\n+  debug \" -Registering %s (for implementation locations)...\" filename;\n   let chrono = timer () in\n   match cmt_sign cmt_contents with\n   | Some sign ->\n@@ -555,6 +742,8 @@ let load_loc_impl parents filename cmt_contents =\n           sign\n       in\n       debug \" %.3fs\\n%!\" (chrono());\n+      let includes = cmt_includes parents t [] cmt_contents in\n+      let t = add_locs ~locs:includes t in\n       Some t\n   | _ ->\n       debug \" %.3fs\\n%!\" (chrono());\n@@ -582,7 +771,7 @@ let load_cmi ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n         let info = Lazy.force info in\n-        debug \"Registering %s...\" file;\n+        debug \" -Registering %s...\" file;\n         let chrono = timer () in\n         let rec implloc_trie = lazy (\n           match Lazy.force impl_cmt with\n@@ -649,7 +838,7 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n          let info = Lazy.force info in\n-         debug \"Registering %s...\" cmt_file;\n+         debug \" -Registering %s...\" cmt_file;\n          let chrono = timer () in\n          let comments = Some (Lazy.from_val info.Cmt_format.cmt_comments) in\n          let rec implloc_trie = lazy (\n@@ -679,6 +868,13 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n          debug \" %.3fs\\n%!\" (chrono());\n          t\n        ) in\n+       let children = lazy (\n+         let includes =\n+           cmt_includes [[modul], children; [], root]\n+             t [] (Lazy.force info)\n+         in\n+         add_locs ~locs:includes (Lazy.force children)\n+       ) in\n        let loc_sig, loc_impl =\n          let of_info i = match i.Cmt_format.cmt_sourcefile with\n            | Some f -> Location.in_file f\ndiff --git a/src/indexMisc.ml b/src/indexMisc.ml\nindex eee8666..8ba66f5 100644\n--- a/src/indexMisc.ml\n+++ b/src/indexMisc.ml\n@@ -57,12 +57,12 @@ let string_to_key s =\n \n let key_to_string l =\n   let rec aux n = function\n-    | [] -> String.create n\n+    | [] -> Bytes.create n\n     | c::r ->\n         let s = aux (n+1) r in\n-        s.[n] <- if c = dot then '.' else c; s\n+        Bytes.set s n (if c = dot then '.' else c); s\n   in\n-  aux 0 l\n+  Bytes.to_string (aux 0 l)\n \n let modpath_to_key ?(enddot=true) path =\n   List.fold_right (fun p acc ->\n@@ -70,22 +70,19 @@ let modpath_to_key ?(enddot=true) path =\n       string_to_key p @ acc) path []\n \n let key_to_modpath l =\n-  let rec aux n = function\n-    | [] -> if n > 0 then [String.create n] else []\n-    | '\\000'::r -> String.create n :: aux 0 r\n-    | c::r ->\n-        match aux (n+1) r with\n-        | s::_ as p -> s.[n] <- c; p\n-        | [] -> assert false\n+  let rec aux acc1 acc2 = function\n+    | '\\000'::r -> aux [] (acc1::acc2) r\n+    | c::r -> aux (c::acc1) acc2 r\n+    | [] -> if acc1 = [] then acc2 else acc1::acc2\n   in\n-  aux 0 l\n+  List.rev_map (fun l -> key_to_string (List.rev l)) (aux [] [] l)\n \n let modpath_to_string path = String.concat \".\" path\n \n let parent_type id =\n   match id.IndexTypes.kind with\n   | Field parent | Variant parent | Method parent -> Some parent\n-  | Type | Value | Exception | Module | ModuleType | Class\n+  | Type | Value | Exception | OpenType | Module | ModuleType | Class\n   | ClassType | Keyword -> None\n \n \ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex d5b5d18..1854bf5 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex c2b5ca6..b82b041 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -159,20 +160,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        tydecl fmt ty\n+    | Osig_type ({ otype_type },_) ->\n+        tydecl fmt otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 1e994d0..974adf3 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex cb1ee67..342f86f 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex d71b99b..9e27b1c 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -44,7 +44,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/ocp-index.ocp b/src/ocp-index.ocp\nindex d7f0fc9..47b1a55 100644\n--- a/src/ocp-index.ocp\n+++ b/src/ocp-index.ocp\n@@ -1,4 +1,5 @@\n-comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n+comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" \"-safe-string\" ]\n+link += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n \n begin library \"ocp-index-lib\"\n   sort = false\n", 
            "name": "ocaml.4.02.patch"
          }, 
          {
            "content": "diff --git a/opam b/opam\nindex 7c58305..0050cb7 100644\n--- a/opam\n+++ b/opam\n@@ -13,7 +13,7 @@ tags: [\n   \"org:ocamlpro\"\n   \"org:typerex\"\n ]\n-dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.02\"\n+dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.03\"\n build: [\n   [\"./configure\" \"--prefix\" prefix]\n   [make]\n@@ -26,7 +26,7 @@ depends: [\n ]\n depopts: \"lambda-term\"\n conflicts: \"lambda-term\" {< \"1.7\"}\n-available: [ocaml-version >= \"4.02.0\" & ocaml-version < \"4.03\"]\n+available: [ocaml-version >= \"4.03\"]\n messages: \"For ocp-browser, please also install package lambda-term\" {! lambda-term:installed}\n post-messages:\n   \"This package requires additional configuration for use in editors. Either install package 'user-setup', or manually:\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex 88b2fa9..a38abfd 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -85,7 +85,7 @@ end = struct\n         Filename.basename\n           (try Filename.chop_extension f with Invalid_argument _ -> f)\n       in\n-      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n+      String.mapi (function 0 -> Char.uppercase_ascii | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex cf914c0..f4fb5a9 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -326,12 +326,21 @@ let trie_of_type_decl ?comments info ty_decl =\n         (fun { Types.cd_id; cd_args; cd_attributes } ->\n           let ty =\n             let params = match cd_args with\n-              | [] -> Outcometree.Otyp_sum []\n-              | param::_ ->\n+              | Cstr_tuple [] -> Outcometree.Otyp_sum []\n+              | Cstr_tuple (param::_ as l) ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple cd_args;\n+                       { Types. desc = Types.Ttuple l;\n                          level = param.Types.level;\n                          id = param.Types.id }\n+              | Cstr_record params ->\n+                  Outcometree.Otyp_record (\n+                    List.map\n+                      (fun l ->\n+                         (Ident.name l.Types.ld_id,\n+                          l.ld_mutable = Mutable,\n+                          Printtyp.tree_of_typexp false l.ld_type)\n+                      )\n+                      params)\n             in\n             Outcometree.Osig_type (Outcometree.{\n                 otype_name    = \"\";\n@@ -925,8 +934,8 @@ let load_files t dirfiles =\n     try\n       let i = String.rindex file '.' in\n       let len = String.length file in\n-      let modul = String.capitalize (String.sub file 0 i) in\n-      let ext = String.lowercase (String.sub file (i+1) (len-i-1)) in\n+      let modul = String.capitalize_ascii (String.sub file 0 i) in\n+      let ext = String.lowercase_ascii (String.sub file (i+1) (len-i-1)) in\n       modul, ext\n     with Not_found -> file, \"\"\n   in\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex b82b041..d9f69a5 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -176,6 +176,8 @@ module IndexFormat = struct\n         tydecl fmt otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n+    | Osig_ellipsis ->\n+        Format.fprintf fmt \"...\"\n \n   let ty ?(colorise = no_color) fmt id =\n     option_iter id.ty\n", 
            "name": "ocaml.4.03.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.3"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.6", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.01.0 < 4.03.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.1.2": {
      "version": "1.1.2", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.2.tar.gz", 
        "checksum": "c9089c112a6dca068df13869708ae704", 
        "files": [
          {
            "content": "diff --git a/src/browserMain.ml b/src/browserMain.ml\nindex 2bd5191..49065a9 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -16,7 +16,7 @@ let rec eq l1 l2 = match l1, l2 with\n let kind_to_tag, tag_to_style, register_ressource =\n   let h = Hashtbl.create 11 in\n   let kind_to_tag = function\n-    | LibIndex.Type -> \"Type\"\n+    | LibIndex.Type | OpenType -> \"Type\"\n     | Value -> \"Value\"\n     | Exception -> \"Exception\"\n     | Field _  -> \"Field\"\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex ce2bb82..2103e3e 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -85,8 +85,7 @@ end = struct\n         Filename.basename\n           (try Filename.chop_extension f with Invalid_argument _ -> f)\n       in\n-      s.[0] <- Char.uppercase s.[0];\n-      s\n+      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex ac77d03..f640bd5 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -36,13 +36,13 @@ let orig_file_name = function\n   | Cmt f | Cmti f | Cmi f -> f\n \n let equal_kind k1 k2 = match k1,k2 with\n-  | Type,Type | Value,Value | Exception,Exception\n+  | Type,Type | Value,Value | Exception,Exception | OpenType,OpenType\n   | Field _,Field _ | Variant _,Variant _ | Method _,Method _\n   | Module,Module | ModuleType,ModuleType\n   | Class,Class | ClassType,ClassType\n   | Keyword,Keyword ->\n       true\n-  | Type,_ | Value,_ | Exception,_\n+  | Type,_ | Value,_ | Exception,_ | OpenType,_\n   | Field _,_ | Variant _,_ | Method _,_\n   | Module,_ | ModuleType,_\n   | Class,_ | ClassType,_\n@@ -146,8 +146,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -220,6 +220,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -227,11 +228,15 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n (* -- end -- *)\n@@ -239,19 +244,16 @@ let qualify_ty_in_sig_item (parents:parents) =\n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n-  (* Sadly the Types tree doesn't contain locations for those. This means we\n-     won't associate comments easily either (todo...) *)\n-  | Types.Sig_module _\n-  | Types.Sig_modtype _\n-  | Types.Sig_class _\n-  | Types.Sig_class_type _\n-    -> Location.none\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_loc\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_loc\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_loc\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_loc\n \n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -261,7 +263,8 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n@@ -270,20 +273,25 @@ let kind_of_sig_item = function\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -294,25 +302,29 @@ let trie_of_type_decl ?comments info ty_decl =\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -322,6 +334,36 @@ let trie_of_type_decl ?comments info ty_decl =\n         variants,\n       comments\n \n+(** Implements looking up a module path in the parents list *)\n+let lookup_parents (parents:parents) path sig_path =\n+  let sig_key, path_key = match sig_path with\n+    | hd::tl ->\n+        modpath_to_key [hd], modpath_to_key tl\n+    | [] -> assert false\n+  in\n+  let rec lookup = function\n+    | [] ->\n+        if debug_enabled then\n+          debug \"WARN: Module or sig reference %s not found a %s\\n\"\n+            (modpath_to_string sig_path)\n+            (modpath_to_string path);\n+        Trie.empty\n+    | (parentpath, lazy t) :: parents ->\n+        let s = Trie.sub t sig_key in\n+        if s = Trie.empty then lookup parents else\n+          let s = Trie.sub s path_key in\n+          let rewrite_path =\n+            fix_path_prefix (List.length parentpath + List.length sig_path) path\n+          in\n+          Trie.map (fun _k v -> rewrite_path v) s\n+  in\n+  lookup parents\n+\n+let rec path_of_ocaml = function\n+  | Path.Pident id -> [id.Ident.name]\n+  | Path.Pdot (path, s, _) -> path_of_ocaml path @ [s]\n+  | Path.Papply (p1, _p2) -> path_of_ocaml p1\n+\n let rec trie_of_sig_item\n     ?comments implloc_trie (parents:parents) (orig_file:orig_file) path\n     sig_item next\n@@ -368,19 +410,21 @@ let rec trie_of_sig_item\n   in\n   (* ignore functor arguments *)\n   let rec sig_item_contents = function\n-    | Types.Sig_module (id, Types.Mty_functor (_,_,s), is_rec) ->\n-        sig_item_contents (Types.Sig_module (id, s, is_rec))\n+    | Types.Sig_module\n+        (id, ({Types.md_type = Types.Mty_functor (_,_,s)} as funct), is_rec) ->\n+        let funct = {funct with Types.md_type = s} in\n+        sig_item_contents (Types.Sig_module (id, funct, is_rec))\n     | Types.Sig_modtype\n-        (id, Types.Modtype_manifest (Types.Mty_functor (_,_,s))) ->\n-        sig_item_contents\n-          (Types.Sig_modtype (id, Types.Modtype_manifest s))\n+        (id, ({Types.mtd_type = Some (Types.Mty_functor (_,_,s))} as funct)) ->\n+        let funct = {funct with Types.mtd_type = Some s} in\n+        sig_item_contents (Types.Sig_modtype (id, funct))\n     | si -> si\n   in\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item_contents sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let children_comments = lazy (\n@@ -400,64 +444,43 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_)\n-    | Types.Sig_modtype (_,Types.Modtype_manifest (Types.Mty_ident sig_ident)) ->\n-        let sig_path =\n-          let rec get_path = function\n-            | Path.Pident id -> [id.Ident.name]\n-            | Path.Pdot (path, s, _) -> get_path path @ [s]\n-            | Path.Papply (p1, _p2) -> get_path p1\n-          in\n-          get_path sig_ident\n-        in\n-        let sig_key, path_key = match sig_path with\n-          | hd::tl ->\n-              modpath_to_key [hd], modpath_to_key tl\n-          | [] -> assert false\n-        in\n-        let rec lookup = function\n-          | [] ->\n-              if debug_enabled then\n-                debug \"WARN: Module or sig reference %s not found a %s\\n\"\n-                  (modpath_to_string sig_path)\n-                  (modpath_to_string (path@[id.Ident.name]));\n-              Trie.empty\n-          | (parentpath, lazy t) :: parents ->\n-              let s = Trie.sub t sig_key in\n-              if s = Trie.empty then lookup parents else\n-                let s = Trie.sub s path_key in\n-                let rewrite_path =\n-                  fix_path_prefix\n-                    (List.length parentpath + List.length sig_path)\n-                    (path @ [id.Ident.name])\n-                in\n-                Trie.map (fun _k v -> rewrite_path v) s\n-        in\n+    | Types.Sig_module (_,{ Types.md_type =\n+                              Types.Mty_ident sig_ident\n+                            | Types.Mty_alias sig_ident},_)\n+    | Types.Sig_modtype (_,{ Types.mtd_type =\n+                               Some ( Types.Mty_ident sig_ident\n+                                    | Types.Mty_alias sig_ident) }) ->\n+        let sig_path = path_of_ocaml sig_ident in\n         let children = lazy (\n           (* Only keep the children, don't override the module reference *)\n-          Trie.graft_lazy Trie.empty [] (lazy (lookup parents))\n+          Trie.graft_lazy Trie.empty []\n+            (lazy (lookup_parents parents (path@[id.Ident.name]) sig_path))\n         ) in\n         children, comments\n     | Types.Sig_class (id,{Types.cty_type=cty},_)\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\n@@ -486,6 +509,139 @@ let rec trie_of_sig_item\n     :: siblings,\n     comments\n \n+\n+(* These four functions go through the typedtree to extract includes *)\n+let rec lookup_trie_of_module_expr parents t path = function\n+  | Typedtree.Tmod_ident (incpath,{ Location.txt = _lid}) ->\n+      let incpath = path_of_ocaml incpath in\n+      debug \"Including %s impl at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+      let parents = (path, lazy t) :: parents in\n+      let sub = lookup_parents parents path incpath in\n+      overriding_merge t sub\n+  | Typedtree.Tmod_constraint (e,_,_,_)\n+  (* | Typedtree.Tmod_apply (e,_,_) *) ->\n+      lookup_trie_of_module_expr parents t path e.mod_desc\n+  | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                          { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                     | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+      let t = lookup_trie_of_module_expr parents t path f.Typedtree.mod_desc in\n+      debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+      let functor_arg = lazy (lookup_parents parents (path_of_ocaml arg) path) in\n+      Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg\n+  | _ -> t\n+let rec extract_includes_from_submodule_sig parents t path name = function\n+  | Typedtree.Tmty_signature sign ->\n+      let path = path @ [name] in\n+      let sub_includes = lazy (\n+        get_includes_sig ((path, lazy t) :: parents)\n+          (Trie.sub t (modpath_to_key [name])) path sign\n+      ) in\n+      Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+  | Typedtree.Tmty_functor (_,_,_,e)\n+  | Typedtree.Tmty_with (e,_) ->\n+      extract_includes_from_submodule_sig parents t path name e.Typedtree.mty_desc\n+  | _ -> t\n+and get_includes_impl parents t path ttree_struct =\n+  let rec extract_submodule_impl t name = function\n+    | Typedtree.Tmod_structure str ->\n+        let path = path @ [name] in\n+        let sub_includes = lazy (\n+          get_includes_impl ((path, lazy t) :: parents)\n+            (Trie.sub t (modpath_to_key [name])) path str\n+        ) in\n+        Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+    (* | Typedtree.Tmod_functor (arg_id,_,arg_t,e) *)\n+    | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                            { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                       | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+        debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+        let functor_arg = lazy (\n+          lookup_parents\n+            ((path, lazy t)::parents) (path_of_ocaml arg) (path@[name])\n+        ) in\n+        extract_submodule_impl\n+          (Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg)\n+          name f.Typedtree.mod_desc\n+    | Typedtree.Tmod_functor (_,_,_,e)\n+    | Typedtree.Tmod_constraint (e,_,_,_) ->\n+        extract_submodule_impl t name e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t struc_item ->\n+      match struc_item.Typedtree.str_desc with\n+      | Typedtree.Tstr_include\n+          { Typedtree.incl_mod = { Typedtree.mod_desc = e }} ->\n+          lookup_trie_of_module_expr parents t path e\n+      | Typedtree.Tstr_open\n+          { Typedtree.open_path = p } ->\n+          let sub = lookup_parents ((path, lazy t) :: parents) path (path_of_ocaml p) in\n+          overriding_merge t sub\n+      | Typedtree.Tstr_module\n+          { Typedtree.mb_id = id; mb_expr = { Typedtree.mod_desc } } ->\n+          extract_submodule_impl t id.Ident.name mod_desc\n+      | Typedtree.Tstr_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.mb_id; mb_expr = { Typedtree.mod_desc } } ->\n+               extract_submodule_impl t mb_id.Ident.name mod_desc)\n+            t l\n+      | Typedtree.Tstr_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc = e } } ->\n+          extract_includes_from_submodule_sig parents t path id.Ident.name e\n+      | _ -> t)\n+    t ttree_struct.Typedtree.str_items\n+and get_includes_sig parents t path ttree_sig =\n+  let rec extract_includes t = function\n+    | Typedtree.Tmty_ident (incpath,_) ->\n+        let incpath = path_of_ocaml incpath in\n+        debug \"Including %s sig at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+        let parents = (path, lazy t) :: parents in\n+        let sub = lookup_parents parents path incpath in\n+        overriding_merge t sub\n+    | Typedtree.Tmty_with (e,_) ->\n+        extract_includes t e.Typedtree.mty_desc\n+    | Typedtree.Tmty_typeof e ->\n+        lookup_trie_of_module_expr parents t path\n+          e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t sig_item ->\n+      match sig_item.Typedtree.sig_desc with\n+      | Typedtree.Tsig_include\n+          { Typedtree.incl_mod = { Typedtree.mty_desc = e }} ->\n+          extract_includes t e\n+      | Typedtree.Tsig_module\n+          { Typedtree.md_id = id ; md_type = { Typedtree.mty_desc } }\n+      | Typedtree.Tsig_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc } } ->\n+          extract_includes_from_submodule_sig parents t path\n+            id.Ident.name mty_desc\n+      | Typedtree.Tsig_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.md_id; md_type = { Typedtree.mty_desc } } ->\n+               extract_includes_from_submodule_sig parents t path\n+                 md_id.Ident.name mty_desc)\n+            t l\n+      | _ -> t)\n+    t ttree_sig.Typedtree.sig_items\n+\n+let add_locs ~locs t =\n+  Trie.map (fun path info ->\n+      let loc_info = lazy (\n+        List.find (has_kind info.kind) (Trie.find_all locs path)\n+      ) in\n+      let lookup fld none =\n+        let loc = Lazy.force (fld info) in\n+        if loc = none\n+        then try Lazy.force (fld (Lazy.force loc_info)) with Not_found -> none\n+        else loc\n+      in\n+      { info with\n+        loc_sig = lazy (lookup (fun i -> i.loc_sig) Location.none);\n+        loc_impl = lazy (lookup (fun i -> i.loc_impl) Location.none);\n+        doc = lazy (lookup (fun i -> i.doc) None);\n+      }\n+    ) t\n+\n (* Can work in a subtree (t doesn't have to be the root) *)\n let qualify_type_idents parents t =\n   let qualify _key id =\n@@ -524,6 +680,14 @@ let cmt_sign cmt_contents =\n     -> Some sign\n   | _ -> None\n \n+let cmt_includes parents t path cmt_contents =\n+  match cmt_contents.Cmt_format.cmt_annots with\n+  | Cmt_format.Implementation impl ->\n+      get_includes_impl parents t path impl\n+  | Cmt_format.Interface sign ->\n+      get_includes_sig parents t path sign\n+  | _ -> Trie.empty\n+\n let protect_read reader f =\n   try reader f with\n   | Cmt_format.Error _ | Cmi_format.Error _ ->\n@@ -539,7 +703,7 @@ let lookup_loc_impl orig_file =\n       if not (Sys.file_exists cmt) then None else Some cmt\n \n let load_loc_impl parents filename cmt_contents =\n-  debug \"Registering %s (for implementation locations)...\" filename;\n+  debug \" -Registering %s (for implementation locations)...\" filename;\n   let chrono = timer () in\n   match cmt_sign cmt_contents with\n   | Some sign ->\n@@ -555,6 +719,8 @@ let load_loc_impl parents filename cmt_contents =\n           sign\n       in\n       debug \" %.3fs\\n%!\" (chrono());\n+      let includes = cmt_includes parents t [] cmt_contents in\n+      let t = add_locs ~locs:includes t in\n       Some t\n   | _ ->\n       debug \" %.3fs\\n%!\" (chrono());\n@@ -582,7 +748,7 @@ let load_cmi ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n         let info = Lazy.force info in\n-        debug \"Registering %s...\" file;\n+        debug \" -Registering %s...\" file;\n         let chrono = timer () in\n         let rec implloc_trie = lazy (\n           match Lazy.force impl_cmt with\n@@ -649,7 +815,7 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n          let info = Lazy.force info in\n-         debug \"Registering %s...\" cmt_file;\n+         debug \" -Registering %s...\" cmt_file;\n          let chrono = timer () in\n          let comments = Some (Lazy.from_val info.Cmt_format.cmt_comments) in\n          let rec implloc_trie = lazy (\n@@ -679,6 +845,13 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n          debug \" %.3fs\\n%!\" (chrono());\n          t\n        ) in\n+       let children = lazy (\n+         let includes =\n+           cmt_includes [[modul], children; [], root]\n+             t [] (Lazy.force info)\n+         in\n+         add_locs ~locs:includes (Lazy.force children)\n+       ) in\n        let loc_sig, loc_impl =\n          let of_info i = match i.Cmt_format.cmt_sourcefile with\n            | Some f -> Location.in_file f\ndiff --git a/src/indexMisc.ml b/src/indexMisc.ml\nindex f3231ce..929d431 100644\n--- a/src/indexMisc.ml\n+++ b/src/indexMisc.ml\n@@ -57,12 +57,12 @@ let string_to_key s =\n \n let key_to_string l =\n   let rec aux n = function\n-    | [] -> String.create n\n+    | [] -> Bytes.create n\n     | c::r ->\n         let s = aux (n+1) r in\n-        s.[n] <- if c = dot then '.' else c; s\n+        Bytes.set s n (if c = dot then '.' else c); s\n   in\n-  aux 0 l\n+  Bytes.to_string (aux 0 l)\n \n let modpath_to_key ?(enddot=true) path =\n   List.fold_right (fun p acc ->\n@@ -70,15 +70,12 @@ let modpath_to_key ?(enddot=true) path =\n       string_to_key p @ acc) path []\n \n let key_to_modpath l =\n-  let rec aux n = function\n-    | [] -> if n > 0 then [String.create n] else []\n-    | '\\000'::r -> String.create n :: aux 0 r\n-    | c::r ->\n-        match aux (n+1) r with\n-        | s::_ as p -> s.[n] <- c; p\n-        | [] -> assert false\n+  let rec aux acc1 acc2 = function\n+    | '\\000'::r -> aux [] (acc1::acc2) r\n+    | c::r -> aux (c::acc1) acc2 r\n+    | [] -> if acc1 = [] then acc2 else acc1::acc2\n   in\n-  aux 0 l\n+  List.rev_map (fun l -> key_to_string (List.rev l)) (aux [] [] l)\n \n let modpath_to_string path = String.concat \".\" path\n \ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex d5b5d18..1854bf5 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex 46e45e2..bf22816 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -159,20 +160,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        tydecl fmt ty\n+    | Osig_type ({ otype_type },_) ->\n+        tydecl fmt otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 1e994d0..974adf3 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex cb1ee67..342f86f 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex d71b99b..9e27b1c 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -44,7 +44,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/ocp-index.ocp b/src/ocp-index.ocp\nindex d7f0fc9..47b1a55 100644\n--- a/src/ocp-index.ocp\n+++ b/src/ocp-index.ocp\n@@ -1,4 +1,5 @@\n-comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n+comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" \"-safe-string\" ]\n+link += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n \n begin library \"ocp-index-lib\"\n   sort = false\n", 
            "name": "ocaml.4.02.patch"
          }, 
          {
            "content": "diff --git a/src/grepMain.ml b/src/grepMain.ml\nindex 2103e3e..cc0212f 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -85,7 +85,7 @@ end = struct\n         Filename.basename\n           (try Filename.chop_extension f with Invalid_argument _ -> f)\n       in\n-      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n+      String.mapi (function 0 -> Char.uppercase_ascii | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex f640bd5..0cc6eb1 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -305,12 +305,21 @@ let trie_of_type_decl ?comments info ty_decl =\n         (fun { Types.cd_id; cd_args } ->\n           let ty =\n             let params = match cd_args with\n-              | [] -> Outcometree.Otyp_sum []\n-              | param::_ ->\n+              | Cstr_tuple [] -> Outcometree.Otyp_sum []\n+              | Cstr_tuple (param::_ as l) ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple cd_args;\n+                       { Types. desc = Types.Ttuple l;\n                          level = param.Types.level;\n                          id = param.Types.id }\n+              | Cstr_record params ->\n+                  Outcometree.Otyp_record (\n+                    List.map\n+                      (fun l ->\n+                         (Ident.name l.Types.ld_id,\n+                          l.ld_mutable = Mutable,\n+                          Printtyp.tree_of_typexp false l.ld_type)\n+                      )\n+                      params)\n             in\n             Outcometree.Osig_type (Outcometree.{\n                 otype_name    = \"\";\n@@ -902,8 +911,8 @@ let load_files t dirfiles =\n     try\n       let i = String.rindex file '.' in\n       let len = String.length file in\n-      let modul = String.capitalize (String.sub file 0 i) in\n-      let ext = String.lowercase (String.sub file (i+1) (len-i-1)) in\n+      let modul = String.capitalize_ascii (String.sub file 0 i) in\n+      let ext = String.lowercase_ascii (String.sub file (i+1) (len-i-1)) in\n       modul, ext\n     with Not_found -> file, \"\"\n   in\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex bf22816..c02821f 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -176,6 +176,8 @@ module IndexFormat = struct\n         tydecl fmt otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n+    | Osig_ellipsis ->\n+        Format.fprintf fmt \"...\"\n \n   let ty ?(colorise = no_color) fmt id =\n     option_iter id.ty\n", 
            "name": "ocaml.4.03.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.2"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.6", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.03.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.0.0": {
      "version": "1.0.0", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.0.0.tar.gz", 
        "checksum": "4dca1473e9f88542321565d2ecd50599", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "make install", 
          "ocp-build install ocp-browser -install-lib $cur__lib -install-bin $cur__bin", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.0.0"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/curses": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/ocp-indent": ">= 1.4.0 < 1.4.1", 
        "@opam/ocp-build": ">= 1.99.4", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.0.1": {
      "version": "1.0.1", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.0.1.tar.gz", 
        "checksum": "115e133483509541a61f0a9d3d094bf2", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.0.1"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/curses": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/ocp-indent": ">= 1.4.1", 
        "@opam/ocp-build": ">= 1.99.4", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.0.2": {
      "version": "1.0.2", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.0.2.tar.gz", 
        "checksum": "34ad3ae71665980ce4b64e5c251640cb", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.0.2"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/curses": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.1", 
        "@opam/ocp-build": ">= 1.99.4", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.0.3": {
      "version": "1.0.3", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.0.3.tar.gz", 
        "checksum": "b9d23d7f46d5d493616236f8b3fec746", 
        "files": [
          {
            "content": "From f50b1a488e25ae3fb9125d2a739b614adfbad6a6 Mon Sep 17 00:00:00 2001\nFrom: Peter Zotov <whitequark@whitequark.org>\nDate: Mon, 12 May 2014 20:18:37 +0400\nSubject: [PATCH] Update for 4.02.\n\n---\n src/browserMain.ml     |  2 +-\n src/indexBuild.ml      | 79 +++++++++++++++++++++++++++++++-------------------\n src/indexOptions.ml    |  2 +-\n src/indexOut.ml        | 13 +++++----\n src/indexPredefined.ml | 27 ++++++++++++-----\n src/indexTypes.ml      |  2 +-\n src/libIndex.mli       |  2 +-\n 7 files changed, 79 insertions(+), 48 deletions(-)\n\ndiff --git a/src/browserMain.ml b/src/browserMain.ml\nindex f34f6d5..fa5c8d0 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -186,7 +186,7 @@ let interactive opts () =\n           LibIndex.Format.no_color\n         else\n           let attr = function\n-            | LibIndex.Type -> Curses.WA.color_pair 6\n+            | LibIndex.Type | LibIndex.OpenType -> Curses.WA.color_pair 6\n             | LibIndex.Value -> Curses.WA.bold\n             | LibIndex.Exception -> Curses.WA.color_pair 3\n             | LibIndex.Field _ | LibIndex.Variant _ -> Curses.WA.color_pair 4\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex 3eddb5e..c25fdf2 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -123,8 +123,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -195,6 +195,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -202,17 +203,21 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n   (* Sadly the Types tree doesn't contain locations for those. This means we\n      won't associate comments easily either (todo...) *)\n   | Types.Sig_module _\n@@ -224,7 +229,7 @@ let loc_of_sig_item = function\n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -234,7 +239,8 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n@@ -243,20 +249,25 @@ let kind_of_sig_item = function\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -267,25 +278,29 @@ let trie_of_type_decl ?comments info ty_decl =\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n@@ -313,7 +328,7 @@ let locate_impl cmt path name kind =\n               sign\n           in\n           match modul with\n-          | Types.Sig_module (_,Types.Mty_signature sign,_) ->\n+          | Types.Sig_module (_, {Types.md_type = Types.Mty_signature sign},_) ->\n               find_item path sign\n           | _ -> raise Not_found\n     in\n@@ -370,8 +385,8 @@ let rec trie_of_sig_item\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let rec children_comments = lazy (\n@@ -392,7 +407,7 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_) ->\n+    | Types.Sig_module (_,{ Types.md_type = Types.Mty_ident sig_ident },_) ->\n         let sig_path =\n           let rec get_path = function\n             | Path.Pident id -> [id.Ident.name]\n@@ -419,22 +434,26 @@ let rec trie_of_sig_item\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex a800e9f..808fe25 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex d95ec8b..9ea17db 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -57,7 +57,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -88,6 +88,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -154,20 +155,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl ty\n+    | Osig_type ({ otype_type },_) ->\n+        Format.fprintf fmt \"@[<hv 2>%a@]\" tydecl otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 5f493bf..0fe7729 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Location.none;\n   loc_impl = lazy Location.none;\n   doc = lazy (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex 252386b..e094317 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex 9e7efa8..b826cf7 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -40,7 +40,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\n-- \n2.0.1\n\n", 
            "name": "0001-Update-for-4.02.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.0.3"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/curses": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.6", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.03.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "0.3.0": {
      "version": "0.3.0", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/0.3.0.tar.gz", 
        "checksum": "04c932570f1d43f3a780edc2d532aa8c", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "ocp-build -init", 
          "ocp-build ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "ocp-build install -install-lib $cur__lib/ocp-index -install-bin $cur__bin -install-data $cur__install/share/typerex ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "sh -c ./_obuild/ocp-index/ocp-index.asm --help=groff > $cur__man/man1/ocp-index.1", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "0.3.0"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "substs": "esy-ocaml/substs", 
        "@opam/ocp-build": ">= 1.99.13", 
        "@opam/cmdliner": "*", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin", 
        "@opam/curses": "*"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "0.2.0": {
      "version": "0.2.0", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/0.2.0.tar.gz", 
        "checksum": "b198abbebceb256c611dd4ccb22e82f3", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "ocp-build -init", 
          "ocp-build ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "ocp-build install -install-lib $cur__lib/ocp-index -install-bin $cur__bin -install-data $cur__install/share/typerex ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "sh -c ./_obuild/ocp-index/ocp-index.asm --help=groff > $cur__man/man1/ocp-index.1", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "0.2.0"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "substs": "esy-ocaml/substs", 
        "@opam/ocp-build": ">= 1.99.13", 
        "@opam/cmdliner": "*", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin", 
        "@opam/curses": "*"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "0.1.0": {
      "version": "0.1.0", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/0.1.0.tar.gz", 
        "checksum": "c10966ef3847bc24c898741eafd467e5", 
        "files": []
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "ocp-build -init", 
          "ocp-build ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "ocp-build install -install-lib $cur__lib/ocp-index -install-bin $cur__bin -install-data $cur__install/share/typerex ocp-index-lib ocp-index ocp-browser ${curses_installed:-false}", 
          "sh -c ./_obuild/ocp-index/ocp-index.asm --help=groff > $cur__man/man1/ocp-index.1", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "0.1.0"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "substs": "esy-ocaml/substs", 
        "@opam/ocp-build": ">= 1.99.13", 
        "@opam/cmdliner": "*", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin", 
        "@opam/curses": "*"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.00.0 < 4.02.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.1.5": {
      "version": "1.1.5", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.5.tar.gz", 
        "checksum": "3d2d70aa17ea046d7b621a75a965da96", 
        "files": [
          {
            "content": "package \"lib\" (\n  version = \"1.1.5\"\n  directory = \"lib\"\n  archive(byte) = \"ocp-index-lib.cma\"\n  archive(native) = \"ocp-index-lib.cmxa\"\n  requires = \"compiler-libs compiler-libs.common ocp-indent.lexer ocp-indent.utils\"\n)\n", 
            "name": "META"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.5"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.13", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.01.0"
      }, 
      "name": "@opam/ocp-index"
    }, 
    "1.1.4": {
      "version": "1.1.4", 
      "opam": {
        "url": "https://github.com/OCamlPro/ocp-index/archive/1.1.4.tar.gz", 
        "checksum": "948cf1fc62492ac502420eb1e24f3876", 
        "files": [
          {
            "content": "diff --git a/opam b/opam\nindex 0fa7477..4220556 100644\n--- a/opam\n+++ b/opam\n@@ -13,7 +13,7 @@ tags: [\n   \"org:ocamlpro\"\n   \"org:typerex\"\n ]\n-dev-repo: \"https://github.com/OCamlPro/ocp-index.git\"\n+dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.02\"\n build: [\n   [\"./configure\" \"--prefix\" prefix]\n   [make]\n@@ -26,7 +26,7 @@ depends: [\n ]\n depopts: \"lambda-term\"\n conflicts: \"lambda-term\" {< \"1.7\"}\n-available: [ocaml-version >= \"4.01.0\" & ocaml-version < \"4.02\"]\n+available: [ocaml-version >= \"4.02.0\" & ocaml-version < \"4.03\"]\n messages: \"For ocp-browser, please also install package lambda-term\" {! lambda-term:installed}\n post-messages:\n   \"This package requires additional configuration for use in editors. Either install package 'user-setup', or manually:\ndiff --git a/src/browserMain.ml b/src/browserMain.ml\nindex 2bd5191..49065a9 100644\n--- a/src/browserMain.ml\n+++ b/src/browserMain.ml\n@@ -16,7 +16,7 @@ let rec eq l1 l2 = match l1, l2 with\n let kind_to_tag, tag_to_style, register_ressource =\n   let h = Hashtbl.create 11 in\n   let kind_to_tag = function\n-    | LibIndex.Type -> \"Type\"\n+    | LibIndex.Type | OpenType -> \"Type\"\n     | Value -> \"Value\"\n     | Exception -> \"Exception\"\n     | Field _  -> \"Field\"\ndiff --git a/src/grepMain.ml b/src/grepMain.ml\nindex 28e7f86..98020f0 100644\n--- a/src/grepMain.ml\n+++ b/src/grepMain.ml\n@@ -85,8 +85,7 @@ end = struct\n         Filename.basename\n           (try Filename.chop_extension f with Invalid_argument _ -> f)\n       in\n-      s.[0] <- Char.uppercase s.[0];\n-      s\n+      String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n     in\n     let f (curpath, lookfor, last_scope, acc) scope tok pos =\n       let lookfor =\ndiff --git a/src/indexBuild.ml b/src/indexBuild.ml\nindex c9edf6c..c026e8d 100644\n--- a/src/indexBuild.ml\n+++ b/src/indexBuild.ml\n@@ -36,13 +36,13 @@ let orig_file_name = function\n   | Cmt f | Cmti f | Cmi f -> f\n \n let equal_kind k1 k2 = match k1,k2 with\n-  | Type,Type | Value,Value | Exception,Exception\n+  | Type,Type | Value,Value | Exception,Exception | OpenType,OpenType\n   | Field _,Field _ | Variant _,Variant _ | Method _,Method _\n   | Module,Module | ModuleType,ModuleType\n   | Class,Class | ClassType,ClassType\n   | Keyword,Keyword ->\n       true\n-  | Type,_ | Value,_ | Exception,_\n+  | Type,_ | Value,_ | Exception,_ | OpenType,_\n   | Field _,_ | Variant _,_ | Method _,_\n   | Module,_ | ModuleType,_\n   | Class,_ | ClassType,_\n@@ -146,8 +146,8 @@ let ty_of_sig_item =\n   function\n   | Types.Sig_value(id, decl) -> tree_of_value_description id decl\n   | Types.Sig_type(id, decl, rs) -> tree_of_type_declaration id decl rs\n-  | Types.Sig_exception(id, decl) -> tree_of_exception_declaration id decl\n-  | Types.Sig_module(id, mty, rs) -> tree_of_module id mty rs\n+  | Types.Sig_typext(id, decl, es) -> tree_of_extension_constructor id decl es\n+  | Types.Sig_module(id, { Types.md_type }, rs) -> tree_of_module id md_type rs\n   | Types.Sig_modtype(id, decl) -> tree_of_modtype_declaration id decl\n   | Types.Sig_class(id, decl, rs) -> tree_of_class_declaration id decl rs\n   | Types.Sig_class_type(id, decl, rs) -> tree_of_cltype_declaration id decl rs\n@@ -220,6 +220,7 @@ let qualify_ty (parents:parents) ty =\n     | Otyp_poly (str, ty) -> Otyp_poly (str, aux ty)\n     | Otyp_module (str, strl, tylist) ->\n         Otyp_module (str, strl, List.map aux tylist)\n+    | Otyp_open -> Otyp_open\n   in\n   aux ty\n \n@@ -227,11 +228,15 @@ let qualify_ty_in_sig_item (parents:parents) =\n   let qual = qualify_ty parents in\n   let open Outcometree in\n   function\n-  | Osig_type ((str, list, ty, priv, tylist2), rc) ->\n-      Osig_type ((str, list, qual ty, priv,\n-        List.map (fun (ty1,ty2) -> qual ty1, qual ty2) tylist2), rc)\n+  | Osig_type (out_type_decl, rc) ->\n+      Osig_type ({ out_type_decl with\n+        otype_type  = qual out_type_decl.otype_type;\n+        otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n+                          out_type_decl.otype_cstrs }, rc)\n   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n-  | Osig_exception (str, tylist) -> Osig_exception (str, List.map qual tylist)\n+  | Osig_typext (constr, es) ->\n+      Osig_typext ({ constr with\n+        oext_args = List.map qual constr.oext_args }, es)\n   | out_sig -> out_sig (* don't get down in modules, classes and their types *)\n \n (* -- end -- *)\n@@ -257,19 +262,16 @@ let with_path_loc ?srcpath loc =\n let loc_of_sig_item = function\n   | Types.Sig_value (_,descr) -> descr.Types.val_loc\n   | Types.Sig_type (_,descr,_) -> descr.Types.type_loc\n-  | Types.Sig_exception (_,descr) -> descr.Types.exn_loc\n-  (* Sadly the Types tree doesn't contain locations for those. This means we\n-     won't associate comments easily either (todo...) *)\n-  | Types.Sig_module _\n-  | Types.Sig_modtype _\n-  | Types.Sig_class _\n-  | Types.Sig_class_type _\n-    -> Location.none\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_loc\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_loc\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_loc\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_loc\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_loc\n \n let id_of_sig_item = function\n   | Types.Sig_value (id,_)\n   | Types.Sig_type (id,_,_)\n-  | Types.Sig_exception (id,_)\n+  | Types.Sig_typext (id,_,_)\n   | Types.Sig_module (id,_,_)\n   | Types.Sig_modtype (id,_)\n   | Types.Sig_class (id,_,_)\n@@ -279,67 +281,129 @@ let id_of_sig_item = function\n let kind_of_sig_item = function\n   | Types.Sig_value _ -> Value\n   | Types.Sig_type _ -> Type\n-  | Types.Sig_exception _ -> Exception\n+  | Types.Sig_typext (_, _, Types.Text_exception) -> Exception\n+  | Types.Sig_typext _ -> OpenType\n   | Types.Sig_module _ -> Module\n   | Types.Sig_modtype _ -> ModuleType\n   | Types.Sig_class _ -> Class\n   | Types.Sig_class_type _ -> ClassType\n \n+let attrs_of_sig_item = function\n+  | Types.Sig_value (_,descr) -> descr.Types.val_attributes\n+  | Types.Sig_type (_,descr,_) -> descr.Types.type_attributes\n+  | Types.Sig_typext (_,descr,_) -> descr.Types.ext_attributes\n+  | Types.Sig_module (_,descr,_) -> descr.Types.md_attributes\n+  | Types.Sig_modtype (_,descr) -> descr.Types.mtd_attributes\n+  | Types.Sig_class (_,descr,_) -> descr.Types.cty_attributes\n+  | Types.Sig_class_type (_,descr,_) -> descr.Types.clty_attributes\n+\n+let doc_of_attributes attrs =\n+  let doc_loc_id = \"ocaml.doc\" in (* not exported ! *)\n+  let open Parsetree in\n+  match List.find (fun ({Location.txt},_) -> txt = doc_loc_id) attrs with\n+  | _, PStr [{pstr_desc = Pstr_eval ({pexp_desc},_)}] ->\n+      (match pexp_desc with\n+       | Pexp_constant (Const_string (s,_)) -> Some s\n+       | _ -> debug \"Unexpected ocaml.doc docstring format\"; None)\n+  | _ -> None\n+  | exception Not_found -> None\n+\n let trie_of_type_decl ?comments info ty_decl =\n   match ty_decl.Types.type_kind with\n   | Types.Type_abstract -> [], comments\n+  | Types.Type_open -> [], comments\n   | Types.Type_record (fields,_repr) ->\n       List.map\n-        (fun (id, _mutable, ty_expr) ->\n-          let ty = Printtyp.tree_of_typexp false ty_expr in\n+        (fun { Types.ld_id; ld_type; ld_attributes } ->\n+          let ty = Printtyp.tree_of_typexp false ld_type in\n           let ty =\n-            Outcometree.Osig_type\n-              ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = ty;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          let doc = doc_of_attributes ld_attributes in\n+          string_to_key ld_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Field info;\n-            name = id.Ident.name;\n+            name = ld_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n-            doc = lazy None;\n+            doc = lazy doc;\n             file = info.file;\n           } ())\n         fields,\n       comments\n   | Types.Type_variant variants ->\n       List.map\n-        (fun (id, ty_exprs, _constraints) ->\n+        (fun { Types.cd_id; cd_args; cd_attributes } ->\n           let ty =\n-            let params = match ty_exprs with\n+            let params = match cd_args with\n               | [] -> Outcometree.Otyp_sum []\n               | param::_ ->\n                      Printtyp.tree_of_typexp false\n-                       { Types. desc = Types.Ttuple ty_exprs;\n+                       { Types. desc = Types.Ttuple cd_args;\n                          level = param.Types.level;\n                          id = param.Types.id }\n             in\n-            Outcometree.Osig_type\n-              ((\"\", [], params, Asttypes.Public, []), Outcometree.Orec_not)\n+            Outcometree.Osig_type (Outcometree.{\n+                otype_name    = \"\";\n+                otype_params  = [];\n+                otype_type    = params;\n+                otype_private = Asttypes.Public;\n+                otype_cstrs   = []; }, Outcometree.Orec_not)\n           in\n-          string_to_key id.Ident.name,\n+          let doc = doc_of_attributes cd_attributes in\n+          string_to_key cd_id.Ident.name,\n           Trie.create ~value:{\n             path = info.path;\n             orig_path = info.path;\n             kind = Variant info;\n-            name = id.Ident.name;\n+            name = cd_id.Ident.name;\n             ty = Some ty;\n             loc_sig = info.loc_sig;\n             loc_impl = info.loc_impl;\n-            doc = lazy None;\n+            doc = lazy doc;\n             file = info.file;\n           } ())\n         variants,\n       comments\n \n+(** Implements looking up a module path in the parents list *)\n+let lookup_parents (parents:parents) path sig_path =\n+  let sig_key, path_key = match sig_path with\n+    | hd::tl ->\n+        modpath_to_key [hd], modpath_to_key tl\n+    | [] -> assert false\n+  in\n+  let rec lookup = function\n+    | [] ->\n+        if debug_enabled then\n+          debug \"WARN: Module or sig reference %s not found a %s\\n\"\n+            (modpath_to_string sig_path)\n+            (modpath_to_string path);\n+        Trie.empty\n+    | (parentpath, lazy t) :: parents ->\n+        let s = Trie.sub t sig_key in\n+        if s = Trie.empty then lookup parents else\n+          let s = Trie.sub s path_key in\n+          let rewrite_path =\n+            fix_path_prefix (List.length parentpath + List.length sig_path) path\n+          in\n+          Trie.map (fun _k v -> rewrite_path v) s\n+  in\n+  lookup parents\n+\n+let rec path_of_ocaml = function\n+  | Path.Pident id -> [id.Ident.name]\n+  | Path.Pdot (path, s, _) -> path_of_ocaml path @ [s]\n+  | Path.Papply (p1, _p2) -> path_of_ocaml p1\n+\n let rec trie_of_sig_item\n     ?comments ?srcpath implloc_trie (parents:parents) (orig_file:orig_file)\n     path sig_item next\n@@ -351,9 +415,10 @@ let rec trie_of_sig_item\n     | Some n -> with_path_loc ?srcpath (loc_of_sig_item n)\n   in\n   let doc, comments =\n-    match comments with\n-    | None -> lazy None, None\n-    | Some comments ->\n+    match doc_of_attributes (attrs_of_sig_item sig_item), comments with\n+    | Some s, _ -> lazy (Some s), comments\n+    | None, None -> lazy None, None\n+    | None, Some comments ->\n         let assoc = lazy (\n           associate_comment (Lazy.force comments) loc nextloc\n         ) in\n@@ -386,19 +451,21 @@ let rec trie_of_sig_item\n   in\n   (* ignore functor arguments *)\n   let rec sig_item_contents = function\n-    | Types.Sig_module (id, Types.Mty_functor (_,_,s), is_rec) ->\n-        sig_item_contents (Types.Sig_module (id, s, is_rec))\n+    | Types.Sig_module\n+        (id, ({Types.md_type = Types.Mty_functor (_,_,s)} as funct), is_rec) ->\n+        let funct = {funct with Types.md_type = s} in\n+        sig_item_contents (Types.Sig_module (id, funct, is_rec))\n     | Types.Sig_modtype\n-        (id, Types.Modtype_manifest (Types.Mty_functor (_,_,s))) ->\n-        sig_item_contents\n-          (Types.Sig_modtype (id, Types.Modtype_manifest s))\n+        (id, ({Types.mtd_type = Some (Types.Mty_functor (_,_,s))} as funct)) ->\n+        let funct = {funct with Types.mtd_type = Some s} in\n+        sig_item_contents (Types.Sig_modtype (id, funct))\n     | si -> si\n   in\n   (* read module / class contents *)\n   let children, comments =\n     match sig_item_contents sig_item with\n-    | Types.Sig_module (id,Types.Mty_signature sign,_)\n-    | Types.Sig_modtype (id,Types.Modtype_manifest (Types.Mty_signature sign))\n+    | Types.Sig_module (id,{ Types.md_type = Types.Mty_signature sign },_)\n+    | Types.Sig_modtype (id,{ Types.mtd_type = Some (Types.Mty_signature sign) })\n       ->\n         let path = path @ [id.Ident.name] in\n         let children_comments = lazy (\n@@ -418,64 +485,43 @@ let rec trie_of_sig_item\n           | Some _, lazy (_, comments) -> comments\n         in\n         children, comments\n-    | Types.Sig_module (_,Types.Mty_ident sig_ident,_)\n-    | Types.Sig_modtype (_,Types.Modtype_manifest (Types.Mty_ident sig_ident)) ->\n-        let sig_path =\n-          let rec get_path = function\n-            | Path.Pident id -> [id.Ident.name]\n-            | Path.Pdot (path, s, _) -> get_path path @ [s]\n-            | Path.Papply (p1, _p2) -> get_path p1\n-          in\n-          get_path sig_ident\n-        in\n-        let sig_key, path_key = match sig_path with\n-          | hd::tl ->\n-              modpath_to_key [hd], modpath_to_key tl\n-          | [] -> assert false\n-        in\n-        let rec lookup = function\n-          | [] ->\n-              if debug_enabled then\n-                debug \"WARN: Module or sig reference %s not found a %s\\n\"\n-                  (modpath_to_string sig_path)\n-                  (modpath_to_string (path@[id.Ident.name]));\n-              Trie.empty\n-          | (parentpath, lazy t) :: parents ->\n-              let s = Trie.sub t sig_key in\n-              if s = Trie.empty then lookup parents else\n-                let s = Trie.sub s path_key in\n-                let rewrite_path =\n-                  fix_path_prefix\n-                    (List.length parentpath + List.length sig_path)\n-                    (path @ [id.Ident.name])\n-                in\n-                Trie.map (fun _k v -> rewrite_path v) s\n-        in\n+    | Types.Sig_module (_,{ Types.md_type =\n+                              Types.Mty_ident sig_ident\n+                            | Types.Mty_alias sig_ident},_)\n+    | Types.Sig_modtype (_,{ Types.mtd_type =\n+                               Some ( Types.Mty_ident sig_ident\n+                                    | Types.Mty_alias sig_ident) }) ->\n+        let sig_path = path_of_ocaml sig_ident in\n         let children = lazy (\n           (* Only keep the children, don't override the module reference *)\n-          Trie.graft_lazy Trie.empty [] (lazy (lookup parents))\n+          Trie.graft_lazy Trie.empty []\n+            (lazy (lookup_parents parents (path@[id.Ident.name]) sig_path))\n         ) in\n         children, comments\n     | Types.Sig_class (id,{Types.cty_type=cty},_)\n     | Types.Sig_class_type (id,{Types.clty_type=cty},_)\n       ->\n         let rec get_clsig = function\n-          | Types.Cty_constr (_,_,cty) | Types.Cty_fun (_,_,cty) ->\n+          | Types.Cty_constr (_,_,cty) | Types.Cty_arrow (_,_,cty) ->\n               get_clsig cty\n           | Types.Cty_signature clsig -> clsig\n         in\n         let clsig = get_clsig cty in\n         let path = path@[id.Ident.name] in\n         let (fields, _) =\n-          Ctype.flatten_fields (Ctype.object_fields clsig.Types.cty_self)\n+          Ctype.flatten_fields (Ctype.object_fields clsig.Types.csig_self)\n         in\n         lazy (List.fold_left (fun t (lbl,_,ty_expr) ->\n             if lbl = \"*dummy method*\" then t else\n               let _ = Printtyp.reset_and_mark_loops ty_expr in\n               let ty = Printtyp.tree_of_typexp false ty_expr in\n               let ty =\n-                Outcometree.Osig_type\n-                  ((\"\", [], ty, Asttypes.Public, []), Outcometree.Orec_not)\n+                Outcometree.Osig_type (Outcometree.{\n+                    otype_name    = \"\";\n+                    otype_params  = [];\n+                    otype_type    = ty;\n+                    otype_private = Asttypes.Public;\n+                    otype_cstrs   = []; }, Outcometree.Orec_not)\n               in\n               Trie.add t (string_to_key lbl)\n                 { path = path;\n@@ -504,6 +550,139 @@ let rec trie_of_sig_item\n     :: siblings,\n     comments\n \n+\n+(* These four functions go through the typedtree to extract includes *)\n+let rec lookup_trie_of_module_expr parents t path = function\n+  | Typedtree.Tmod_ident (incpath,{ Location.txt = _lid}) ->\n+      let incpath = path_of_ocaml incpath in\n+      debug \"Including %s impl at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+      let parents = (path, lazy t) :: parents in\n+      let sub = lookup_parents parents path incpath in\n+      overriding_merge t sub\n+  | Typedtree.Tmod_constraint (e,_,_,_)\n+  (* | Typedtree.Tmod_apply (e,_,_) *) ->\n+      lookup_trie_of_module_expr parents t path e.mod_desc\n+  | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                          { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                     | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+      let t = lookup_trie_of_module_expr parents t path f.Typedtree.mod_desc in\n+      debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+      let functor_arg = lazy (lookup_parents parents (path_of_ocaml arg) path) in\n+      Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg\n+  | _ -> t\n+let rec extract_includes_from_submodule_sig parents t path name = function\n+  | Typedtree.Tmty_signature sign ->\n+      let path = path @ [name] in\n+      let sub_includes = lazy (\n+        get_includes_sig ((path, lazy t) :: parents)\n+          (Trie.sub t (modpath_to_key [name])) path sign\n+      ) in\n+      Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+  | Typedtree.Tmty_functor (_,_,_,e)\n+  | Typedtree.Tmty_with (e,_) ->\n+      extract_includes_from_submodule_sig parents t path name e.Typedtree.mty_desc\n+  | _ -> t\n+and get_includes_impl parents t path ttree_struct =\n+  let rec extract_submodule_impl t name = function\n+    | Typedtree.Tmod_structure str ->\n+        let path = path @ [name] in\n+        let sub_includes = lazy (\n+          get_includes_impl ((path, lazy t) :: parents)\n+            (Trie.sub t (modpath_to_key [name])) path str\n+        ) in\n+        Trie.graft_lazy t (modpath_to_key [name]) sub_includes\n+    (* | Typedtree.Tmod_functor (arg_id,_,arg_t,e) *)\n+    | Typedtree.Tmod_apply ({ mod_desc = Typedtree.Tmod_functor(id,_,_,f) },\n+                            { mod_desc = Typedtree.Tmod_ident (arg,_)\n+                                       | Typedtree.Tmod_constraint ({mod_desc = Typedtree.Tmod_ident (arg,_)},_,_,_)  },_) ->\n+        debug \"Grafting %s at %s\\n\" id.Ident.name (modpath_to_string (path_of_ocaml arg));\n+        let functor_arg = lazy (\n+          lookup_parents\n+            ((path, lazy t)::parents) (path_of_ocaml arg) (path@[name])\n+        ) in\n+        extract_submodule_impl\n+          (Trie.graft_lazy t (modpath_to_key [id.Ident.name]) functor_arg)\n+          name f.Typedtree.mod_desc\n+    | Typedtree.Tmod_functor (_,_,_,e)\n+    | Typedtree.Tmod_constraint (e,_,_,_) ->\n+        extract_submodule_impl t name e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t struc_item ->\n+      match struc_item.Typedtree.str_desc with\n+      | Typedtree.Tstr_include\n+          { Typedtree.incl_mod = { Typedtree.mod_desc = e }} ->\n+          lookup_trie_of_module_expr parents t path e\n+      | Typedtree.Tstr_open\n+          { Typedtree.open_path = p } ->\n+          let sub = lookup_parents ((path, lazy t) :: parents) path (path_of_ocaml p) in\n+          overriding_merge t sub\n+      | Typedtree.Tstr_module\n+          { Typedtree.mb_id = id; mb_expr = { Typedtree.mod_desc } } ->\n+          extract_submodule_impl t id.Ident.name mod_desc\n+      | Typedtree.Tstr_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.mb_id; mb_expr = { Typedtree.mod_desc } } ->\n+               extract_submodule_impl t mb_id.Ident.name mod_desc)\n+            t l\n+      | Typedtree.Tstr_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc = e } } ->\n+          extract_includes_from_submodule_sig parents t path id.Ident.name e\n+      | _ -> t)\n+    t ttree_struct.Typedtree.str_items\n+and get_includes_sig parents t path ttree_sig =\n+  let rec extract_includes t = function\n+    | Typedtree.Tmty_ident (incpath,_) ->\n+        let incpath = path_of_ocaml incpath in\n+        debug \"Including %s sig at %s\\n\" (modpath_to_string incpath) (modpath_to_string path);\n+        let parents = (path, lazy t) :: parents in\n+        let sub = lookup_parents parents path incpath in\n+        overriding_merge t sub\n+    | Typedtree.Tmty_with (e,_) ->\n+        extract_includes t e.Typedtree.mty_desc\n+    | Typedtree.Tmty_typeof e ->\n+        lookup_trie_of_module_expr parents t path\n+          e.Typedtree.mod_desc\n+    | _ -> t\n+  in\n+  List.fold_left (fun t sig_item ->\n+      match sig_item.Typedtree.sig_desc with\n+      | Typedtree.Tsig_include\n+          { Typedtree.incl_mod = { Typedtree.mty_desc = e }} ->\n+          extract_includes t e\n+      | Typedtree.Tsig_module\n+          { Typedtree.md_id = id ; md_type = { Typedtree.mty_desc } }\n+      | Typedtree.Tsig_modtype\n+          { Typedtree.mtd_id = id; mtd_type = Some { Typedtree.mty_desc } } ->\n+          extract_includes_from_submodule_sig parents t path\n+            id.Ident.name mty_desc\n+      | Typedtree.Tsig_recmodule l ->\n+          List.fold_left\n+            (fun t { Typedtree.md_id; md_type = { Typedtree.mty_desc } } ->\n+               extract_includes_from_submodule_sig parents t path\n+                 md_id.Ident.name mty_desc)\n+            t l\n+      | _ -> t)\n+    t ttree_sig.Typedtree.sig_items\n+\n+let add_locs ~locs t =\n+  Trie.map (fun path info ->\n+      let loc_info = lazy (\n+        List.find (has_kind info.kind) (Trie.find_all locs path)\n+      ) in\n+      let lookup fld none =\n+        let loc = Lazy.force (fld info) in\n+        if loc = none\n+        then try Lazy.force (fld (Lazy.force loc_info)) with Not_found -> none\n+        else loc\n+      in\n+      { info with\n+        loc_sig = lazy (lookup (fun i -> i.loc_sig) Location.none);\n+        loc_impl = lazy (lookup (fun i -> i.loc_impl) Location.none);\n+        doc = lazy (lookup (fun i -> i.doc) None);\n+      }\n+    ) t\n+\n (* Can work in a subtree (t doesn't have to be the root) *)\n let qualify_type_idents parents t =\n   let qualify _key id =\n@@ -542,6 +721,14 @@ let cmt_sign cmt_contents =\n     -> Some sign\n   | _ -> None\n \n+let cmt_includes parents t path cmt_contents =\n+  match cmt_contents.Cmt_format.cmt_annots with\n+  | Cmt_format.Implementation impl ->\n+      get_includes_impl parents t path impl\n+  | Cmt_format.Interface sign ->\n+      get_includes_sig parents t path sign\n+  | _ -> Trie.empty\n+\n let protect_read reader f =\n   try reader f with\n   | Cmt_format.Error _ | Cmi_format.Error _ ->\n@@ -557,7 +744,7 @@ let lookup_loc_impl orig_file =\n       if not (Sys.file_exists cmt) then None else Some cmt\n \n let load_loc_impl parents filename cmt_contents =\n-  debug \"Registering %s (for implementation locations)...\" filename;\n+  debug \" -Registering %s (for implementation locations)...\" filename;\n   let chrono = timer () in\n   match cmt_sign cmt_contents with\n   | Some sign ->\n@@ -574,6 +761,8 @@ let load_loc_impl parents filename cmt_contents =\n           sign\n       in\n       debug \" %.3fs\\n%!\" (chrono());\n+      let includes = cmt_includes parents t [] cmt_contents in\n+      let t = add_locs ~locs:includes t in\n       Some t\n   | _ ->\n       debug \" %.3fs\\n%!\" (chrono());\n@@ -601,7 +790,7 @@ let load_cmi ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n         let info = Lazy.force info in\n-        debug \"Registering %s...\" file;\n+        debug \" -Registering %s...\" file;\n         let chrono = timer () in\n         let rec implloc_trie = lazy (\n           match Lazy.force impl_cmt with\n@@ -668,7 +857,7 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n        ) in\n        let children = lazy (\n          let info = Lazy.force info in\n-         debug \"Registering %s...\" cmt_file;\n+         debug \" -Registering %s...\" cmt_file;\n          let chrono = timer () in\n          let comments = Some (Lazy.from_val info.Cmt_format.cmt_comments) in\n          let rec implloc_trie = lazy (\n@@ -700,6 +889,13 @@ let load_cmt ?(qualify=false) root t modul orig_file =\n          debug \" %.3fs\\n%!\" (chrono());\n          t\n        ) in\n+       let children = lazy (\n+         let includes =\n+           cmt_includes [[modul], children; [], root]\n+             t [] (Lazy.force info)\n+         in\n+         add_locs ~locs:includes (Lazy.force children)\n+       ) in\n        let loc_sig, loc_impl =\n          let of_info i = match i.Cmt_format.cmt_sourcefile with\n            | Some f -> Location.in_file f\ndiff --git a/src/indexMisc.ml b/src/indexMisc.ml\nindex eee8666..8ba66f5 100644\n--- a/src/indexMisc.ml\n+++ b/src/indexMisc.ml\n@@ -57,12 +57,12 @@ let string_to_key s =\n \n let key_to_string l =\n   let rec aux n = function\n-    | [] -> String.create n\n+    | [] -> Bytes.create n\n     | c::r ->\n         let s = aux (n+1) r in\n-        s.[n] <- if c = dot then '.' else c; s\n+        Bytes.set s n (if c = dot then '.' else c); s\n   in\n-  aux 0 l\n+  Bytes.to_string (aux 0 l)\n \n let modpath_to_key ?(enddot=true) path =\n   List.fold_right (fun p acc ->\n@@ -70,22 +70,19 @@ let modpath_to_key ?(enddot=true) path =\n       string_to_key p @ acc) path []\n \n let key_to_modpath l =\n-  let rec aux n = function\n-    | [] -> if n > 0 then [String.create n] else []\n-    | '\\000'::r -> String.create n :: aux 0 r\n-    | c::r ->\n-        match aux (n+1) r with\n-        | s::_ as p -> s.[n] <- c; p\n-        | [] -> assert false\n+  let rec aux acc1 acc2 = function\n+    | '\\000'::r -> aux [] (acc1::acc2) r\n+    | c::r -> aux (c::acc1) acc2 r\n+    | [] -> if acc1 = [] then acc2 else acc1::acc2\n   in\n-  aux 0 l\n+  List.rev_map (fun l -> key_to_string (List.rev l)) (aux [] [] l)\n \n let modpath_to_string path = String.concat \".\" path\n \n let parent_type id =\n   match id.IndexTypes.kind with\n   | Field parent | Variant parent | Method parent -> Some parent\n-  | Type | Value | Exception | Module | ModuleType | Class\n+  | Type | Value | Exception | OpenType | Module | ModuleType | Class\n   | ClassType | Keyword -> None\n \n \ndiff --git a/src/indexOptions.ml b/src/indexOptions.ml\nindex c37d0ef..a1e55c4 100644\n--- a/src/indexOptions.ml\n+++ b/src/indexOptions.ml\n@@ -37,7 +37,7 @@ let filter opt info =\n   let open LibIndex in\n   let kinds = opt.filter in\n   match info.kind with\n-  | Type -> kinds.t\n+  | Type | OpenType -> kinds.t\n   | Value | Method _ -> kinds.v\n   | Exception -> kinds.e\n   | Field _ | Variant _ -> kinds.c\ndiff --git a/src/indexOut.ml b/src/indexOut.ml\nindex 37b6a2a..3ab29c8 100644\n--- a/src/indexOut.ml\n+++ b/src/indexOut.ml\n@@ -64,7 +64,7 @@ module IndexFormat = struct\n   let color =\n     let f kind fstr fmt =\n       let colorcode = match kind with\n-        | Type -> \"\\027[36m\"\n+        | Type | OpenType -> \"\\027[36m\"\n         | Value -> \"\\027[1m\"\n         | Exception -> \"\\027[33m\"\n         | Field _ | Variant _ -> \"\\027[34m\"\n@@ -95,6 +95,7 @@ module IndexFormat = struct\n     | Type -> Format.pp_print_string fmt \"type\"\n     | Value -> Format.pp_print_string fmt \"val\"\n     | Exception -> Format.pp_print_string fmt \"exception\"\n+    | OpenType -> Format.pp_print_string fmt \"opentype\"\n     | Field parentty ->\n         Format.fprintf fmt \"field(%a)\"\n           (colorise.f parentty.kind \"%s\") parentty.name\n@@ -166,20 +167,20 @@ module IndexFormat = struct\n     | Osig_class (_,_,_,ctyp,_)\n     | Osig_class_type (_,_,_,ctyp,_) ->\n         !Oprint.out_class_type fmt ctyp\n-    | Osig_exception (_,[]) ->\n+    | Osig_typext ({ oext_args = [] }, _) ->\n         Format.pp_print_char fmt '-'\n-    | Osig_exception (_,tylst) ->\n+    | Osig_typext ({ oext_args }, _) ->\n         list ~paren:true\n           !Oprint.out_type\n           (fun fmt () ->\n             Format.pp_print_char fmt ','; Format.pp_print_space fmt ())\n           fmt\n-          tylst\n+          oext_args\n     | Osig_modtype (_,mtyp)\n     | Osig_module (_,mtyp,_) ->\n         !Oprint.out_module_type fmt mtyp\n-    | Osig_type ((_,_,ty,_,_),_) ->\n-        tydecl fmt ty\n+    | Osig_type ({ otype_type },_) ->\n+        tydecl fmt otype_type\n     | Osig_value (_,ty,_) ->\n         !Oprint.out_type fmt ty\n \ndiff --git a/src/indexPredefined.ml b/src/indexPredefined.ml\nindex 1e994d0..974adf3 100644\n--- a/src/indexPredefined.ml\n+++ b/src/indexPredefined.ml\n@@ -24,8 +24,11 @@ let mktype name ?(params=[]) ?(def=Otyp_abstract) doc = {\n   kind = Type;\n   name = name;\n   ty = Some (Osig_type (\n-      (name,List.map (fun v -> v,(true,true)) params,def,Asttypes.Public,[]),\n-      Orec_not));\n+      { otype_name    = name;\n+        otype_params  = List.map (fun v -> v,(true,true)) params;\n+        otype_type    = def;\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\n@@ -37,11 +40,13 @@ let mkvariant name parent params = {\n   orig_path = [];\n   kind = Variant parent;\n   name = name;\n-  ty = Some (Osig_type ((\"\", [],\n-                         (match params with [] -> Otyp_sum []\n-                                          | l -> Otyp_tuple l),\n-                         Asttypes.Public, []),\n-                        Outcometree.Orec_not));\n+  ty = Some (Osig_type (\n+      { otype_name    = \"\";\n+        otype_params  = [];\n+        otype_type    = (match params with [] -> Otyp_sum []\n+                                         | l  -> Otyp_tuple l);\n+        otype_private = Asttypes.Public;\n+        otype_cstrs   = [] }, Orec_not));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val None;\n@@ -53,7 +58,13 @@ let mkexn name params doc = {\n   orig_path = [];\n   kind = Exception;\n   name = name;\n-  ty = Some (Osig_exception (name,params));\n+  ty = Some (Osig_typext ({\n+        oext_name        = name;\n+        oext_type_name   = \"exn\";\n+        oext_type_params = [];\n+        oext_args        = params;\n+        oext_ret_type    = None;\n+        oext_private     = Asttypes.Public }, Oext_exception));\n   loc_sig = Lazy.from_val Location.none;\n   loc_impl = Lazy.from_val Location.none;\n   doc = Lazy.from_val (Some doc);\ndiff --git a/src/indexTypes.ml b/src/indexTypes.ml\nindex cb1ee67..342f86f 100644\n--- a/src/indexTypes.ml\n+++ b/src/indexTypes.ml\n@@ -35,7 +35,7 @@ type info = { path: string list;\n \n (** The kind of elements that can be stored in the trie *)\n and kind =\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/libIndex.mli b/src/libIndex.mli\nindex d71b99b..9e27b1c 100644\n--- a/src/libIndex.mli\n+++ b/src/libIndex.mli\n@@ -44,7 +44,7 @@ type info = IndexTypes.info = private {\n \n (** The kind of elements that can be stored in the trie *)\n and kind = IndexTypes.kind = private\n-  | Type | Value | Exception\n+  | Type | Value | Exception | OpenType\n   | Field of info | Variant of info\n   | Method of info\n   | Module | ModuleType\ndiff --git a/src/ocp-index.ocp b/src/ocp-index.ocp\nindex d7f0fc9..47b1a55 100644\n--- a/src/ocp-index.ocp\n+++ b/src/ocp-index.ocp\n@@ -1,4 +1,5 @@\n-comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n+comp += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" \"-safe-string\" ]\n+link += [ \"-g\" \"-w\" \"+1..39-4-9-37-40\" ]\n \n begin library \"ocp-index-lib\"\n   sort = false\n", 
            "name": "ocaml.4.02.patch"
          }, 
          {
            "content": "diff -r -C 2 ocp-index.1.1.4.orig/opam ocp-index.1.1.4/opam\n*** ocp-index.1.1.4.orig/opam\t2016-05-12 11:00:19.040179931 +0200\n--- ocp-index.1.1.4/opam\t2016-05-12 11:00:58.084181600 +0200\n***************\n*** 14,18 ****\n    \"org:typerex\"\n  ]\n! dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.02\"\n  build: [\n    [\"./configure\" \"--prefix\" prefix]\n--- 14,18 ----\n    \"org:typerex\"\n  ]\n! dev-repo: \"https://github.com/OCamlPro/ocp-index.git#4.03\"\n  build: [\n    [\"./configure\" \"--prefix\" prefix]\n***************\n*** 27,31 ****\n  depopts: \"lambda-term\"\n  conflicts: \"lambda-term\" {< \"1.7\"}\n! available: [ocaml-version >= \"4.02.0\" & ocaml-version < \"4.03\"]\n  messages: \"For ocp-browser, please also install package lambda-term\" {! lambda-term:installed}\n  post-messages:\n--- 27,31 ----\n  depopts: \"lambda-term\"\n  conflicts: \"lambda-term\" {< \"1.7\"}\n! available: [ocaml-version >= \"4.03\"]\n  messages: \"For ocp-browser, please also install package lambda-term\" {! lambda-term:installed}\n  post-messages:\ndiff -r -C 2 ocp-index.1.1.4.orig/src/grepMain.ml ocp-index.1.1.4/src/grepMain.ml\n*** ocp-index.1.1.4.orig/src/grepMain.ml\t2016-05-12 11:00:19.040179931 +0200\n--- ocp-index.1.1.4/src/grepMain.ml\t2016-05-12 11:00:58.152181603 +0200\n***************\n*** 86,90 ****\n            (try Filename.chop_extension f with Invalid_argument _ -> f)\n        in\n!       String.mapi (function 0 -> Char.uppercase | _ -> fun x -> x) s\n      in\n      let f (curpath, lookfor, last_scope, acc) scope tok pos =\n--- 86,90 ----\n            (try Filename.chop_extension f with Invalid_argument _ -> f)\n        in\n!       String.mapi (function 0 -> Char.uppercase_ascii | _ -> fun x -> x) s\n      in\n      let f (curpath, lookfor, last_scope, acc) scope tok pos =\ndiff -r -C 2 ocp-index.1.1.4.orig/src/indexBuild.ml ocp-index.1.1.4/src/indexBuild.ml\n*** ocp-index.1.1.4.orig/src/indexBuild.ml\t2016-05-12 11:00:19.040179931 +0200\n--- ocp-index.1.1.4/src/indexBuild.ml\t2016-05-12 11:00:58.152181603 +0200\n***************\n*** 222,225 ****\n--- 222,226 ----\n          Otyp_module (str, strl, List.map aux tylist)\n      | Otyp_open -> Otyp_open\n+     | Otyp_attribute (ty,attr) -> Otyp_attribute(aux ty,attr)\n    in\n    aux ty\n***************\n*** 234,238 ****\n          otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n                            out_type_decl.otype_cstrs }, rc)\n!   | Osig_value (str, ty, str2) -> Osig_value (str, qual ty, str2)\n    | Osig_typext (constr, es) ->\n        Osig_typext ({ constr with\n--- 235,239 ----\n          otype_cstrs = List.map (fun (ty1,ty2) -> qual ty1, qual ty2)\n                            out_type_decl.otype_cstrs }, rc)\n!   | Osig_value v -> Osig_value { v with oval_type = qual v.oval_type }\n    | Osig_typext (constr, es) ->\n        Osig_typext ({ constr with\n***************\n*** 304,308 ****\n    | _, PStr [{pstr_desc = Pstr_eval ({pexp_desc},_)}] ->\n        (match pexp_desc with\n!        | Pexp_constant (Const_string (s,_)) -> Some s\n         | _ -> debug \"Unexpected ocaml.doc docstring format\"; None)\n    | _ -> None\n--- 305,309 ----\n    | _, PStr [{pstr_desc = Pstr_eval ({pexp_desc},_)}] ->\n        (match pexp_desc with\n!        | Pexp_constant (Pconst_string (s,_)) -> Some s\n         | _ -> debug \"Unexpected ocaml.doc docstring format\"; None)\n    | _ -> None\n***************\n*** 323,326 ****\n--- 324,328 ----\n                  otype_type    = ty;\n                  otype_private = Asttypes.Public;\n+                 otype_immediate = false;\n                  otype_cstrs   = []; }, Outcometree.Orec_not)\n            in\n***************\n*** 345,354 ****\n            let ty =\n              let params = match cd_args with\n!               | [] -> Outcometree.Otyp_sum []\n!               | param::_ ->\n                       Printtyp.tree_of_typexp false\n!                        { Types. desc = Types.Ttuple cd_args;\n                           level = param.Types.level;\n                           id = param.Types.id }\n              in\n              Outcometree.Osig_type (Outcometree.{\n--- 347,365 ----\n            let ty =\n              let params = match cd_args with\n!               | Cstr_tuple [] -> Outcometree.Otyp_sum []\n!               | Cstr_tuple (param::_ as l) ->\n                       Printtyp.tree_of_typexp false\n!                        { Types. desc = Types.Ttuple l;\n                           level = param.Types.level;\n                           id = param.Types.id }\n+               | Cstr_record params ->\n+                   Outcometree.Otyp_record (\n+                     List.map\n+                       (fun l ->\n+                          (Ident.name l.Types.ld_id,\n+                           l.ld_mutable = Mutable,\n+                           Printtyp.tree_of_typexp false l.ld_type)\n+                       )\n+                       params)\n              in\n              Outcometree.Osig_type (Outcometree.{\n***************\n*** 357,360 ****\n--- 368,372 ----\n                  otype_type    = params;\n                  otype_private = Asttypes.Public;\n+                 otype_immediate = false;\n                  otype_cstrs   = []; }, Outcometree.Orec_not)\n            in\n***************\n*** 522,525 ****\n--- 534,538 ----\n                      otype_type    = ty;\n                      otype_private = Asttypes.Public;\n+                     otype_immediate = false;\n                      otype_cstrs   = []; }, Outcometree.Orec_not)\n                in\n***************\n*** 947,952 ****\n        let i = String.rindex file '.' in\n        let len = String.length file in\n!       let modul = String.capitalize (String.sub file 0 i) in\n!       let ext = String.lowercase (String.sub file (i+1) (len-i-1)) in\n        modul, ext\n      with Not_found -> file, \"\"\n--- 960,965 ----\n        let i = String.rindex file '.' in\n        let len = String.length file in\n!       let modul = String.capitalize_ascii (String.sub file 0 i) in\n!       let ext = String.lowercase_ascii (String.sub file (i+1) (len-i-1)) in\n        modul, ext\n      with Not_found -> file, \"\"\ndiff -r -C 2 ocp-index.1.1.4.orig/src/indexOut.ml ocp-index.1.1.4/src/indexOut.ml\n*** ocp-index.1.1.4.orig/src/indexOut.ml\t2016-05-12 11:00:19.040179931 +0200\n--- ocp-index.1.1.4/src/indexOut.ml\t2016-05-12 11:00:58.152181603 +0200\n***************\n*** 182,187 ****\n      | Osig_type ({ otype_type },_) ->\n          tydecl fmt otype_type\n!     | Osig_value (_,ty,_) ->\n          !Oprint.out_type fmt ty\n  \n    let ty ?(colorise = no_color) fmt id =\n--- 182,189 ----\n      | Osig_type ({ otype_type },_) ->\n          tydecl fmt otype_type\n!     | Osig_value { oval_type = ty } ->\n          !Oprint.out_type fmt ty\n+     | Osig_ellipsis ->\n+         Format.fprintf fmt \"...\"\n  \n    let ty ?(colorise = no_color) fmt id =\ndiff -r -C 2 ocp-index.1.1.4.orig/src/indexPredefined.ml ocp-index.1.1.4/src/indexPredefined.ml\n*** ocp-index.1.1.4.orig/src/indexPredefined.ml\t2016-05-12 11:00:19.040179931 +0200\n--- ocp-index.1.1.4/src/indexPredefined.ml\t2016-05-12 11:00:58.152181603 +0200\n***************\n*** 29,32 ****\n--- 29,33 ----\n          otype_type    = def;\n          otype_private = Asttypes.Public;\n+         otype_immediate = false;\n          otype_cstrs   = [] }, Orec_not));\n    loc_sig = Lazy.from_val Location.none;\n***************\n*** 46,49 ****\n--- 47,51 ----\n          otype_type    = (match params with [] -> Otyp_sum []\n                                           | l  -> Otyp_tuple l);\n+         otype_immediate = false;\n          otype_private = Asttypes.Public;\n          otype_cstrs   = [] }, Orec_not));\n", 
            "name": "ocaml.4.03.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "ocp_index_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "ocp_index_version": {
            "scope": "global", 
            "val": "1.1.4"
          }, 
          "ocp_index_enable": {
            "scope": "global", 
            "val": "enable"
          }
        }
      }, 
      "dependencies": {
        "@opam/cmdliner": "*", 
        "@opam/lambda-term": "*", 
        "substs": "esy-ocaml/substs", 
        "@opam/re": "*", 
        "@opam/ocp-indent": ">= 1.4.2", 
        "@opam/ocp-build": ">= 1.99.15", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.01.0"
      }, 
      "name": "@opam/ocp-index"
    }
  }
}