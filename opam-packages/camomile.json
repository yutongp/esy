{
  "versions": {
    "0.8.5": {
      "version": "0.8.5", 
      "opam": {
        "url": "https://github.com/yoriyuki/Camomile/releases/download/rel-0.8.5/camomile-0.8.5.tar.bz2", 
        "checksum": "1e25b6cd4efd26ab38a667db18d83f02", 
        "files": [
          {
            "content": "diff --git a/Makefile.in b/Makefile.in\nindex 56a2597..f24253b 100644\n--- a/Makefile.in\n+++ b/Makefile.in\n@@ -399,8 +399,8 @@ install-without-ocamlfind:\n \tif [ -f camomile.a ]; then cp -f camomile.a '$(OCAMLLIB)'; fi\n \n install-with-ocamlfind:\n-\tfiles= &&\\\n-\tif [ -f camomileLibrary.cmx ]; then files=camomileLibrary.cmx; fi && \\\n+\tfiles=\"$(wildcard public/*.cmx internal/*.cmx)\" &&\\\n+\tif [ -f camomileLibrary.cmx ]; then files=\"camomileLibrary.cmx $$files\"; fi && \\\n \tif [ -f camomileLibrary.cma ]; then files=\"camomileLibrary.cma $$files\"; fi && \\\n \tif [ -f camomileLibrary.cmxa ]; then files=\"camomileLibrary.cmxa $$files\"; fi && \\\n \tif [ -f camomileLibraryDefault.cmx ]; then files=\"camomileLibraryDefault.cmx $$files\"; fi && \\\n", 
            "name": "cmx.patch"
          }, 
          {
            "content": "diff --git a/META.in b/META.in\nindex a231f19..18a8229 100644\n--- a/META.in\n+++ b/META.in\n@@ -5,4 +5,5 @@ requires=\"bigarray\"\n \n archive(byte)=\"camomile.cma\"\n archive(native)=\"camomile.cmxa\"\n+archive(native, plugin)=\"camomile.cmxs\"\n \ndiff --git a/Makefile.in b/Makefile.in\nindex 7afe20f..9dc8862 100644\n--- a/Makefile.in\n+++ b/Makefile.in\n@@ -121,7 +121,7 @@ internal/uReStrParser.cmo : internal/uReStrParser.cmi\n internal/uReStrParser.cmx : internal/uReStrParser.cmi\n \n byte : camomile.cma camomileLibrary.cma\n-opt : camomile.cmxa camomileLibrary.cmxa\n+opt : camomile.cmxa camomile.cmxs camomileLibrary.cmxa\n \n $(NOOBJ_INT:.cmi=.cmo) : %.cmo : %.mli %.cmi\n \t$(OCAMLC) -c $(BFLAGS) -impl $<\n@@ -139,6 +139,8 @@ camomile.cma : $(OBJECTS) camomileLibrary.cmo camomileLibraryDefault.cmo camomil\n \t$(OCAMLC) -a -o camomile.cma $(OBJECTS) camomileLibrary.cmo camomileLibraryDefault.cmo camomileLibraryDyn.cmo\n camomile.cmxa : $(OPTOBJECTS) camomileLibrary.cmx camomileLibraryDefault.cmx camomileLibraryDyn.cmx\n \t$(OCAMLOPT) -a -o camomile.cmxa $(OPTOBJECTS) camomileLibrary.cmx camomileLibraryDefault.cmx camomileLibraryDyn.cmx\n+camomile.cmxs : camomile.cmxa\n+\t$(OCAMLOPT) -shared -linkall -o camomile.cmxs camomile.cmxa\n \n camomileLibrary.cma : $(OBJECTS) camomileLibrary.cmo\n \t$(OCAMLC) -a -o camomileLibrary.cma $(OBJECTS) camomileLibrary.cmo\n@@ -401,6 +403,7 @@ install-without-ocamlfind:\n \tif [ -f camomileLibraryDyn.cmx ]; then cp -f camomileLibraryDyn.cmx '$(OCAMLLIB)'; fi\n \tif [ -f camomile.cma ]; then cp -f camomile.cma '$(OCAMLLIB)'; fi\n \tif [ -f camomile.cmxa ]; then cp -f camomile.cmxa '$(OCAMLLIB)'; fi\n+\tif [ -f camomile.cmxs ]; then cp -f camomile.cmxs '$(OCAMLLIB)'; fi\n \tif [ -f camomile.a ]; then cp -f camomile.a '$(OCAMLLIB)'; fi\n \n install-with-ocamlfind:\n@@ -412,6 +415,7 @@ install-with-ocamlfind:\n \tif [ -f camomileLibraryDyn.cmx ]; then files=\"camomileLibraryDyn.cmx $$files\"; fi && \\\n \tif [ -f camomile.cma ]; then files=\"camomile.cma $$files\"; fi&& \\\n \tif [ -f camomile.cmxa ]; then files=\"camomile.cmxa $$files\"; fi&& \\\n+\tif [ -f camomile.cmxs ]; then files=\"camomile.cmxs $$files\"; fi&& \\\n \tif [ -f camomile.a ]; then files=\"camomile.a $$files\"; fi && \\\n \tocamlfind install camomile $$files META $(MLI) camomileLibrary.cmi camomileLibraryDefault.cmi camomileLibraryDyn.cmi\n \n@@ -508,7 +512,7 @@ tags :\n \totags */*.ml */*.mli *.ml *.mli\n \n clean :\n-\trm -f *.cm[ioxa] *.cmxa *.o *.so *.a */*.cm[iox] */*.o pocaml\\\n+\trm -f *.cm[ioxa] *.cmxa *.cmxs *.o *.so *.a */*.cm[iox] */*.o pocaml\\\n \t*/*.byte */*.opt\n \trm -f database/*.mar\n \trm -f charmaps/*.mar\n", 
            "name": "cmxs.patch"
          }, 
          {
            "content": "diff -urN camomile-0.8.5-orig/configure camomile-0.8.5/configure\n--- camomile-0.8.5-orig/configure\t2013-09-15 11:07:31.000000000 +0400\n+++ camomile-0.8.5/configure\t2014-10-22 17:15:05.785847212 +0400\n@@ -2341,10 +2341,6 @@\n fi\n \n \n-if test \"$CAMLP4O\" = no ; then\n-\tas_fn_error $? \"Cannot find camlp4o.\" \"$LINENO\" 5\n-fi\n-\n # Extract the first word of \"ocamlfind\", so it can be a program name with args.\n set dummy ocamlfind; ac_word=$2\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\ndiff -urN camomile-0.8.5-orig/Makefile.in camomile-0.8.5/Makefile.in\n--- camomile-0.8.5-orig/Makefile.in\t2013-09-15 11:48:38.000000000 +0400\n+++ camomile-0.8.5/Makefile.in\t2014-10-22 16:39:34.633832673 +0400\n@@ -41,7 +41,6 @@\n OCAMLLIB = @OCAMLLIB@\n OCAMLBEST= @OCAMLBEST@\n OCAMLVERSION = @OCAMLVERSION@\n-CAMLP4O = -pp \"@CAMLP4O@ -I $(OCAMLLIB)\"\n INSTALL = @OCAMLINSTALL@\n UNINSTALL = un@OCAMLINSTALL@\n OCAMLDOC = @OCAMLDOC@\n@@ -214,12 +213,6 @@\n $(OPTTOOLS) : %.opt : toolslib.cmxa %.cmx\n \t$(OCAMLOPT) $(OFLAGS) -o $@ $(OPTTOOLSLIB) $*.cmx\n \n-tools/camomilelocaledef.cmo : tools/camomilelocaledef.ml\n-\t$(OCAMLC) $(CAMLP4O) -c $(BFLAGS) tools/camomilelocaledef.ml\n-\n-tools/camomilelocaledef.cmx : tools/camomilelocaledef.ml\n-\t$(OCAMLOPT) $(CAMLP4O) -c $(OFLAGS) tools/camomilelocaledef.ml\n-\n # Compile unidata\n ###################################################################\n \n@@ -536,7 +529,7 @@\n \tmappings/*.ml mappings/*.mli \\\n \ttoolslib/*.ml toolslib/*.mli \\\n \t> .depend\n-\t$(OCAMLDEP) $(CAMLP4O) $(SUBDIR) \\\n+\t$(OCAMLDEP) $(SUBDIR) \\\n \ttools/$(TOOLS:.byte=.ml) >> .depend\n \n include .depend\ndiff -urN camomile-0.8.5-orig/tools/camomilelocaledef.ml camomile-0.8.5/tools/camomilelocaledef.ml\n--- camomile-0.8.5-orig/tools/camomilelocaledef.ml\t2012-10-12 15:51:14.000000000 +0400\n+++ camomile-0.8.5/tools/camomilelocaledef.ml\t2014-10-22 16:30:25.000000000 +0400\n@@ -1,12 +1,9 @@\n (** Locale definition compiler *)\n-\n (* Copyright (C) 2002, 2003, 2011 Yamagata Yoriyuki *)\n-\n (* This library is free software; you can redistribute it and/or *)\n (* modify it under the terms of the GNU Lesser General Public License *)\n (* as published by the Free Software Foundation; either version 2 of *)\n (* the License, or (at your option) any later version. *)\n-\n (* As a special exception to the GNU Library General Public License, you *)\n (* may link, statically or dynamically, a \"work that uses this library\" *)\n (* with a publicly distributed version of this library to produce an *)\n@@ -20,221 +17,312 @@\n (* License. This exception does not however invalidate any other reasons *)\n (* why the executable file might be covered by the GNU Library General *)\n (* Public License . *)\n-\n (* This library is distributed in the hope that it will be useful, *)\n (* but WITHOUT ANY WARRANTY; without even the implied warranty of *)\n (* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n (* Lesser General Public License for more details. *)\n-\n (* You should have received a copy of the GNU Lesser General Public *)\n (* License along with this library; if not, write to the Free Software *)\n (* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 *)\n (* USA *)\n-\n (* You can contact the authour by sending email to *)\n (* yori@users.sourceforge.net *)\n-\n-\n open Toolslib\n+  \n open AbsCe\n+  \n module CE = CharEncoding.Configure(Camomileconfig)\n+  \n module Info = UCharInfo.Make(Camomileconfig)\n-\n-let enc, readfile, dir =\n+  \n+let (enc, readfile, dir) =\n   let enc = ref CE.utf8 in\n   let readfile = ref stdin in\n-  let dir = ref Filename.current_dir_name in\n-  Arg.parse\n-    [\"--enc\", Arg.String (fun encname ->\n-      enc := CE.of_name encname), \"Encoding name\";\n-     \"--file\", Arg.String (fun filename ->\n-       readfile := open_in_bin filename), \"Reading file\"]\n-    (fun dirname -> dir := dirname)\n-    \"camomilelocaledef --enc ENCNAME --file INPUTFILE DIRECTORY:\\n\\\n+  let dir = ref Filename.current_dir_name\n+  in\n+    (Arg.parse\n+       [ (\"--enc\", (Arg.String (fun encname -> enc := CE.of_name encname)),\n+          \"Encoding name\");\n+         (\"--file\",\n+          (Arg.String (fun filename -> readfile := open_in_bin filename)),\n+          \"Reading file\") ]\n+       (fun dirname -> dir := dirname)\n+       \"camomilelocaledef --enc ENCNAME --file INPUTFILE DIRECTORY:\\n\\\n     Read the localedef INPUTFILE using the encoding ENCNAME \\\n and put the compiled data into DIRECTORY. \\\n     If ENCNAME is ommited, UTF-8 is used.  \\\n     If INPUTFILE is ommited, reading from stdin. \\\n     If DIRECTORY is ommited, the current directory is used.\";\n-    !enc, !readfile, !dir\n-\n+     ((!enc), (!readfile), (!dir)))\n+  \n module Utf8Buffer = UTF8.Buf\n+  \n module Utf8NF = UNF.Make(Camomileconfig)(UTF8)\n-\n-let ff = 0x000c\t\t\t\t(*form feed*)\n+  \n+let ff = 0x000c\n+  \n+(*form feed*)\n let cr = Char.code '\\r'\n+  \n let lf = Char.code '\\n'\n+  \n let nel = 0x0085\n+  \n let tab = Char.code '\\t'\n-\n+  \n let backslash = Char.code '\\\\'\n+  \n let sq = Char.code '\\\\'\n+  \n let dq = Char.code '\"'\n-\n+  \n let backslash = Str.regexp \"\\\\\\\\\\\\\\\\\"\n-let literal_1 = Str.regexp \n-    \"\\\\\\\\[u]\\\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]\\\\)\"\n-\n-let literal_2 = Str.regexp\n+  \n+let literal_1 =\n+  Str.regexp \"\\\\\\\\[u]\\\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]\\\\)\"\n+  \n+let literal_2 =\n+  Str.regexp\n     \"\\\\\\\\[v]\\\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]\\\\)\"\n-\n+  \n let unescape s =\n-  let s = \n-    Str.global_substitute literal_1 (fun _ ->\n-      let n = int_of_string (Str.replace_matched \"0x\\\\1\" s) in\n-      UTF8.init 1 (fun _ -> (UChar.chr_of_uint n))) \n-      s in\n-  let s = \n-    Str.global_substitute literal_2 (fun _ ->\n-      let n = int_of_string (Str.replace_matched \"0x\\\\1\" s) in\n-      UTF8.init 1 (fun _ -> (UChar.chr_of_uint n))) \n+  let s =\n+    Str.global_substitute literal_1\n+      (fun _ ->\n+         let n = int_of_string (Str.replace_matched \"0x\\\\1\" s)\n+         in UTF8.init 1 (fun _ -> UChar.chr_of_uint n))\n       s in\n-  Str.global_replace backslash \"\\\\\\\\\" s\n-\n-let rec stream_to_list_aux a s = (parser\n-    [< 'e; rest >] -> stream_to_list_aux (e :: a) rest\n-  | [< >] -> List.rev a) s\n-\n+  let s =\n+    Str.global_substitute literal_2\n+      (fun _ ->\n+         let n = int_of_string (Str.replace_matched \"0x\\\\1\" s)\n+         in UTF8.init 1 (fun _ -> UChar.chr_of_uint n))\n+      s\n+  in Str.global_replace backslash \"\\\\\\\\\" s\n+  \n+let rec stream_to_list_aux a s =\n+  (fun (__strm : _ Stream.t) ->\n+     match Stream.peek __strm with\n+     | Some e -> (Stream.junk __strm; stream_to_list_aux (e :: a) __strm)\n+     | _ -> List.rev a)\n+    s\n+  \n let stream_to_list s = stream_to_list_aux [] s\n+  \n+type token = | Text of string | Brace_r | Brace_l | Colon | Comma\n \n-type token = \n-    Text of string\n-  | Brace_r\n-  | Brace_l\n-  | Colon\n-  | Comma\n-\n-let rec prep = parser \n-    [< 'u; rest >] ->\n-      let c = try Some (UChar.char_of u) with _ -> None in\n-      (match Info.general_category u with\n-\t`Cc | `Cf when c <> Some '\\n' ->  prep rest\n-      | ct -> [< '(c, ct, u); prep rest >])\n-  | [< >] -> [< >]\n-\n-let rec remove_comment = parser\n-    [< '( Some '/', _, _) as data; rest >] ->\n-      (parser\n-\t  [< '(Some '/', _, _); rest >] -> comment rest\n-\t| [< '(Some '*', _, _); rest >] -> comment2 rest\n-\t| [< rest >] -> [< 'data; remove_comment rest >])\n-\trest\n-  | [< '( Some '\"', _, _) as data; rest >]  -> \n-      [< 'data; in_quote rest >]\n-  | [< 'data; rest >] -> [< 'data; remove_comment rest >]\n-  | [< >] -> [< >]\n-and comment = parser\n-    [< '( Some ('\\r' | '\\n' | '\\133'), _, _) | ( _, (`Zl | `Zp), _); rest >] \n-    -> remove_comment rest\n-  | [< 'data; rest >] -> comment rest\n-  | [< >] -> [< >]\n-and comment2 = parser\n-    [< '( Some '*', _, _) as data; rest >] -> (parser\n-\t[<  '(Some '/', _, _); rest >] -> remove_comment rest\n-      |\t[< rest >] -> comment2 rest) rest\n-  | [< 'data; rest >] -> comment2 rest\n-  | [< >] -> [< >]\n-and in_quote = parser\n-    [< '( Some '\\\\', _, _) as data1; 'data2; rest >] ->\n-      [< 'data1; 'data2; in_quote rest >]\n-  | [< '( Some '\"', _, _) as data; rest >]  -> \n-      [<' data; remove_comment rest >]\n-  | [< 'data; rest >] -> [< 'data; in_quote rest >]\n-  | [< >] -> [< >]\n-\n-let rec merge_text = parser\n-    [< 'Text s; rest >] -> do_merge s rest\n-  | [< 'e; rest >] -> [< 'e; merge_text rest >]\n-  | [< >] -> [< >]\n-and do_merge s = parser\n-    [< 'Text s'; rest >] -> do_merge (s ^ s') rest\n-  | [< 'e; rest >] -> [< 'Text s; 'e; merge_text rest >]\n-  | [< >] -> [< >]\n-\n+let rec prep (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some u ->\n+      (Stream.junk __strm;\n+       let rest = __strm in\n+       let c = (try Some (UChar.char_of u) with | _ -> None)\n+       in\n+         (match Info.general_category u with\n+          | `Cc | `Cf when c <> (Some '\\n') -> prep rest\n+          | ct ->\n+              Stream.lcons (fun _ -> (c, ct, u))\n+                (Stream.slazy (fun _ -> prep rest))))\n+  | _ -> Stream.sempty\n+  \n+let rec remove_comment (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some (((Some '/', _, _) as data)) ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in\n+         (fun (__strm : _ Stream.t) ->\n+            match Stream.peek __strm with\n+            | Some ((Some '/', _, _)) -> (Stream.junk __strm; comment __strm)\n+            | Some ((Some '*', _, _)) ->\n+                (Stream.junk __strm; comment2 __strm)\n+            | _ ->\n+                let rest = __strm\n+                in\n+                  Stream.icons data\n+                    (Stream.slazy (fun _ -> remove_comment rest)))\n+           rest)\n+  | Some (((Some '\"', _, _) as data)) ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in Stream.icons data (Stream.slazy (fun _ -> in_quote rest)))\n+  | Some data ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in Stream.icons data (Stream.slazy (fun _ -> remove_comment rest)))\n+  | _ -> Stream.sempty\n+and comment (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some ((Some ('\\r' | '\\n' | '\\133'), _, _) | (_, (`Zl | `Zp), _)) ->\n+      (Stream.junk __strm; remove_comment __strm)\n+  | Some data -> (Stream.junk __strm; comment __strm)\n+  | _ -> Stream.sempty\n+and comment2 (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some (((Some '*', _, _) as data)) ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in\n+         (fun (__strm : _ Stream.t) ->\n+            match Stream.peek __strm with\n+            | Some ((Some '/', _, _)) ->\n+                (Stream.junk __strm; remove_comment __strm)\n+            | _ -> comment2 __strm)\n+           rest)\n+  | Some data -> (Stream.junk __strm; comment2 __strm)\n+  | _ -> Stream.sempty\n+and in_quote (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some (((Some '\\\\', _, _) as data1)) ->\n+      (Stream.junk __strm;\n+       (match Stream.peek __strm with\n+        | Some data2 ->\n+            (Stream.junk __strm;\n+             let rest = __strm\n+             in\n+               Stream.icons data1\n+                 (Stream.icons data2 (Stream.slazy (fun _ -> in_quote rest))))\n+        | _ -> raise (Stream.Error \"\")))\n+  | Some (((Some '\"', _, _) as data)) ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in Stream.icons data (Stream.slazy (fun _ -> remove_comment rest)))\n+  | Some data ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in Stream.icons data (Stream.slazy (fun _ -> in_quote rest)))\n+  | _ -> Stream.sempty\n+  \n+let rec merge_text (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some (Text s) -> (Stream.junk __strm; do_merge s __strm)\n+  | Some e ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in Stream.icons e (Stream.slazy (fun _ -> merge_text rest)))\n+  | _ -> Stream.sempty\n+and do_merge s (__strm : _ Stream.t) =\n+  match Stream.peek __strm with\n+  | Some (Text s') -> (Stream.junk __strm; do_merge (s ^ s') __strm)\n+  | Some e ->\n+      (Stream.junk __strm;\n+       let rest = __strm\n+       in\n+         Stream.icons (Text s)\n+           (Stream.icons e (Stream.slazy (fun _ -> merge_text rest))))\n+  | _ -> Stream.sempty\n+  \n let lexer s =\n-  let rec parse = parser\n-      [< '( Some '{', _, _); rest >] -> [< 'Brace_l; parse rest >]\n-    | [< '( Some '}', _, _); rest >] -> [< 'Brace_r; parse rest >]\n-    | [< '( Some ':', _, _); rest >] -> [< 'Colon; parse rest >]\n-    | [< '( Some ',', _, _); rest >] -> [< 'Comma; parse rest >]\n-    | [< '( Some '\"', _, _); rest >] -> quote rest\n-    | [< '( Some ('\\r' | '\\n' | '\\133' | '\\t'), _, _)\n-    | ( _, (`Zs | `Zl | `Zp), _) ; rest >] ->\n-\tparse rest\n-    | [< 'e; rest >] -> text [< 'e; rest >]\n-    | [< >] -> [< >]\n+  let rec parse (__strm : _ Stream.t) =\n+    match Stream.peek __strm with\n+    | Some ((Some '{', _, _)) ->\n+        (Stream.junk __strm;\n+         let rest = __strm\n+         in Stream.icons Brace_l (Stream.slazy (fun _ -> parse rest)))\n+    | Some ((Some '}', _, _)) ->\n+        (Stream.junk __strm;\n+         let rest = __strm\n+         in Stream.icons Brace_r (Stream.slazy (fun _ -> parse rest)))\n+    | Some ((Some ':', _, _)) ->\n+        (Stream.junk __strm;\n+         let rest = __strm\n+         in Stream.icons Colon (Stream.slazy (fun _ -> parse rest)))\n+    | Some ((Some ',', _, _)) ->\n+        (Stream.junk __strm;\n+         let rest = __strm\n+         in Stream.icons Comma (Stream.slazy (fun _ -> parse rest)))\n+    | Some ((Some '\"', _, _)) -> (Stream.junk __strm; quote __strm)\n+    | Some\n+        ((Some ('\\r' | '\\n' | '\\133' | '\\t'), _, _) |\n+           (_, (`Zs | `Zl | `Zp), _))\n+        -> (Stream.junk __strm; parse __strm)\n+    | Some e ->\n+        (Stream.junk __strm; let rest = __strm in text (Stream.icons e rest))\n+    | _ -> Stream.sempty\n   and quote s =\n     let buf = Utf8Buffer.create 16 in\n-    let rec loop = parser\n-\t[< '( Some '\\\\', _, u1); '(_, _, u2); rest >] ->\n-\t  Utf8Buffer.add_char buf u1;\n-\t  Utf8Buffer.add_char buf u2;\n-\t  loop rest\n-      |\t[< '( Some '\"', _, _); rest >]  -> \n-\t  let s = Utf8Buffer.contents buf in\n-\t  let s' = unescape s in\n-\t  [< 'Text s'; parse rest >]\n-      |\t[< '( _, _, u); rest >] ->\n-\t  Utf8Buffer.add_char buf u;\n-\t  loop rest\n-      | [< >] -> failwith \"A quote is not enclosed.\"\n-    in\n-    loop s\n+    let rec loop (__strm : _ Stream.t) =\n+      match Stream.peek __strm with\n+      | Some ((Some '\\\\', _, u1)) ->\n+          (Stream.junk __strm;\n+           (match Stream.peek __strm with\n+            | Some ((_, _, u2)) ->\n+                (Stream.junk __strm;\n+                 let rest = __strm\n+                 in\n+                   (Utf8Buffer.add_char buf u1;\n+                    Utf8Buffer.add_char buf u2;\n+                    loop rest))\n+            | _ -> raise (Stream.Error \"\")))\n+      | Some ((Some '\"', _, _)) ->\n+          (Stream.junk __strm;\n+           let rest = __strm in\n+           let s = Utf8Buffer.contents buf in\n+           let s' = unescape s\n+           in Stream.icons (Text s') (Stream.slazy (fun _ -> parse rest)))\n+      | Some ((_, _, u)) ->\n+          (Stream.junk __strm;\n+           let rest = __strm in (Utf8Buffer.add_char buf u; loop rest))\n+      | _ -> failwith \"A quote is not enclosed.\"\n+    in loop s\n   and text s =\n     let buf = Utf8Buffer.create 16 in\n-    let rec loop = parser\n-\t[<'( Some ('\\r' | '\\n' | '\\133' | '\\t'), _, _) | \n-\t( _, (`Zs | `Zl | `Zp), _) ; rest >] ->\n-\t  let s = Utf8Buffer.contents buf in\n-\t  let s' = unescape s in\n-\t  [< 'Text s'; parse rest >]\n-      |\t[< '( Some ('{' | '}' | ':' | ','| '\"'), _, _) as e; rest >] ->\n-\t  let s = Utf8Buffer.contents buf in\n-\t  let s' = unescape s in\n-\t  [< 'Text s'; parse [< 'e; rest >] >]\n-      |\t[< '( _, _, u); rest >] ->\n-\t  Utf8Buffer.add_char buf u;\n-\t  loop rest\n-      |\t[< >] ->\n-\t  let s = Utf8Buffer.contents buf in\n-\t  let s' = unescape s in\n-\t  [< 'Text s' >]\n-    in\n-    loop s\n-  in\n+    let rec loop (__strm : _ Stream.t) =\n+      match Stream.peek __strm with\n+      | Some\n+          ((Some ('\\r' | '\\n' | '\\133' | '\\t'), _, _) |\n+             (_, (`Zs | `Zl | `Zp), _))\n+          ->\n+          (Stream.junk __strm;\n+           let rest = __strm in\n+           let s = Utf8Buffer.contents buf in\n+           let s' = unescape s\n+           in Stream.icons (Text s') (Stream.slazy (fun _ -> parse rest)))\n+      | Some (((Some ('{' | '}' | ':' | ',' | '\"'), _, _) as e)) ->\n+          (Stream.junk __strm;\n+           let rest = __strm in\n+           let s = Utf8Buffer.contents buf in\n+           let s' = unescape s\n+           in\n+             Stream.icons (Text s')\n+               (Stream.slazy (fun _ -> parse (Stream.icons e rest))))\n+      | Some ((_, _, u)) ->\n+          (Stream.junk __strm;\n+           let rest = __strm in (Utf8Buffer.add_char buf u; loop rest))\n+      | _ ->\n+          let s = Utf8Buffer.contents buf in\n+          let s' = unescape s in Stream.ising (Text s')\n+    in loop s in\n   let p = prep s in\n   let p1 = remove_comment p in\n   let tokens = parse p1 in\n-  let tokens1 = merge_text tokens in\n-  let l = stream_to_list tokens1 in l\n-\n+  let tokens1 = merge_text tokens in let l = stream_to_list tokens1 in l\n+  \n let string_to_binary s =\n-  let n = String.length s / 2 in\n-  let b = String.create n in\n-  for i = 0 to n - 1 do\n-    let d = int_of_string (\"0x\" ^ (String.sub s (i * 2) 2)) in\n-    b.[i] <- Char.chr d\n-  done;\n-  b\n-\n+  let n = (String.length s) / 2 in\n+  let b = String.create n\n+  in\n+    (for i = 0 to n - 1 do\n+       (let d = int_of_string (\"0x\" ^ (String.sub s (i * 2) 2))\n+        in b.[i] <- Char.chr d)\n+     done;\n+     b)\n+  \n let root = ref \"\"\n-\n+  \n let load_file filename =\n   let file =\n-    if Filename.is_implicit filename then\n-      Filename.concat !root filename else\n-      filename\n-  in\n+    if Filename.is_implicit filename\n+    then Filename.concat !root filename\n+    else filename in\n   let c = open_in_bin file in\n-  let buf = Buffer.create 16 in\n-  try begin while true do\n-    Buffer.add_channel buf c 1\n-  done; assert false end\n-  with End_of_file ->\n-    Buffer.contents buf\n-\n-type data = \n-    Table of (string, data) Hashtbl.t\n+  let buf = Buffer.create 16\n+  in\n+    try (while true do Buffer.add_channel buf c 1 done; assert false)\n+    with | End_of_file -> Buffer.contents buf\n+  \n+type data =\n+  | Table of (string, data) Hashtbl.t\n   | Array_data of data array\n   | String_data of string\n   | Binary of string\n@@ -244,125 +332,119 @@\n \n let rec parse_intvect l a =\n   match l with\n-    Text num :: Comma :: rest ->\n+  | Text num :: Comma :: rest ->\n       parse_intvect rest ((int_of_string num) :: a)\n   | Text num :: rest ->\n-      Intvect (Array.of_list (List.rev ((int_of_string num) :: a))), rest\n-  | _ -> \n-      Intvect (Array.of_list (List.rev a)), l\n-\n+      ((Intvect (Array.of_list (List.rev ((int_of_string num) :: a)))), rest)\n+  | _ -> ((Intvect (Array.of_list (List.rev a))), l)\n+  \n let rec parse_table l a =\n   match parse l with\n-    Some d, rest -> parse_table rest (d :: a)\n-  | None, rest -> \n+  | (Some d, rest) -> parse_table rest (d :: a)\n+  | (None, rest) ->\n       let tbl = Hashtbl.create (List.length a) in\n       let proc ent =\n-\tmatch ent with\n-\t  Tagged (name, data) ->\n-\t    Hashtbl.add tbl name data\n-\t| _ -> failwith \"A broken table entry.\"\n-      in\n-      List.iter proc a;\n-      Table tbl, rest\n-\n+        (match ent with\n+         | Tagged (name, data) -> Hashtbl.add tbl name data\n+         | _ -> failwith \"A broken table entry.\")\n+      in (List.iter proc a; ((Table tbl), rest))\n and parse_array l a =\n   match l with\n-    Brace_l :: rest ->\n-      let data, rest = parse_unknown rest in\n-      (match rest with\n-\tBrace_r :: Comma :: rest -> \n-\t  parse_array rest (data :: a)\n-      |\tBrace_r :: rest -> \n-\t  parse_array rest (data :: a)\n-      |\t_ -> failwith \"A brace is not enclosed.\")\n-  | Text text :: Comma :: rest ->\n-      parse_array rest ((String_data text) :: a)\n+  | Brace_l :: rest ->\n+      let (data, rest) = parse_unknown rest\n+      in\n+        (match rest with\n+         | Brace_r :: Comma :: rest -> parse_array rest (data :: a)\n+         | Brace_r :: rest -> parse_array rest (data :: a)\n+         | _ -> failwith \"A brace is not enclosed.\")\n+  | Text text :: Comma :: rest -> parse_array rest ((String_data text) :: a)\n   | Text text :: rest ->\n-      Array_data (Array.of_list (List.rev ((String_data text) :: a))), rest\n-  | _ ->\n-      Array_data (Array.of_list (List.rev a)), l\n-\n+      ((Array_data (Array.of_list (List.rev ((String_data text) :: a)))),\n+       rest)\n+  | _ -> ((Array_data (Array.of_list (List.rev a))), l)\n and parse_unknown l =\n   match l with\n-    Text text :: Brace_r :: rest ->\n-      String_data text, Brace_r :: rest\n+  | Text text :: Brace_r :: rest -> ((String_data text), (Brace_r :: rest))\n   | Text text :: Comma :: rest -> parse_array l []\n   | Text text :: rest -> parse_table l []\n   | _ -> parse_array l []\n-\n-and parse l = match l with\n-    Text tname :: Colon :: Text \"table\" :: Brace_l :: rest ->\n-      let data, rest = parse_table rest [] in\n-      (match rest with\n-\tBrace_r :: rest ->\n-\t  Some (Tagged (tname, data)), rest\n-      |\t_ -> failwith \"A brace is not enclosed.\")\n+and parse l =\n+  match l with\n+  | Text tname :: Colon :: Text \"table\" :: Brace_l :: rest ->\n+      let (data, rest) = parse_table rest []\n+      in\n+        (match rest with\n+         | Brace_r :: rest -> ((Some (Tagged (tname, data))), rest)\n+         | _ -> failwith \"A brace is not enclosed.\")\n   | Text tname :: Colon :: Text \"array\" :: Brace_l :: rest ->\n-      let data, rest = parse_array rest [] in\n-      (match rest with\n-\tBrace_r :: rest ->\n-\t  Some (Tagged (tname, data)), rest\n-      |\t_ -> failwith \"A brace is not enclosed.\")\n-  | Text tname :: Colon :: Text \"string\" :: Brace_l ::\n-    Text data :: Brace_r :: rest ->  \n-      Some (Tagged (tname, String_data data)), rest\n-  | Text tname :: Colon :: Text \"bin\" :: Brace_l :: \n-    Text data :: Brace_r :: rest ->\n-      let b = string_to_binary data in\n-      Some (Tagged (tname, Binary b)), rest\n-  | Text tname :: Colon :: Text \"import\" :: Brace_l ::\n-    Text filename :: Brace_r :: rest ->\n-      prerr_endline \"Warning : file loading is not supported.\";\n-      Some (Tagged (tname, Binary \"\")), rest\n-  | Text tname :: Colon :: Text \"int\" :: Brace_l ::\n-    Text num :: Brace_r :: rest ->\n-      let n = int_of_string num in\n-      Some (Tagged (tname, Int n)), rest\n+      let (data, rest) = parse_array rest []\n+      in\n+        (match rest with\n+         | Brace_r :: rest -> ((Some (Tagged (tname, data))), rest)\n+         | _ -> failwith \"A brace is not enclosed.\")\n+  | Text tname :: Colon :: Text \"string\" :: Brace_l :: Text data ::\n+      Brace_r :: rest -> ((Some (Tagged (tname, (String_data data)))), rest)\n+  | Text tname :: Colon :: Text \"bin\" :: Brace_l :: Text data :: Brace_r ::\n+      rest ->\n+      let b = string_to_binary data\n+      in ((Some (Tagged (tname, (Binary b)))), rest)\n+  | Text tname :: Colon :: Text \"import\" :: Brace_l :: Text filename ::\n+      Brace_r :: rest ->\n+      (prerr_endline \"Warning : file loading is not supported.\";\n+       ((Some (Tagged (tname, (Binary \"\")))), rest))\n+  | Text tname :: Colon :: Text \"int\" :: Brace_l :: Text num :: Brace_r ::\n+      rest ->\n+      let n = int_of_string num in ((Some (Tagged (tname, (Int n)))), rest)\n   | Text tname :: Colon :: Text \"intvector\" :: Brace_l :: rest ->\n-      let data, rest = parse_intvect rest [] in\n-      (match rest with\n-\tBrace_r :: rest ->\n-\t  Some (Tagged (tname, data)), rest\n-      |\t_ -> failwith \"A brace is not enclosed.\")\n+      let (data, rest) = parse_intvect rest []\n+      in\n+        (match rest with\n+         | Brace_r :: rest -> ((Some (Tagged (tname, data))), rest)\n+         | _ -> failwith \"A brace is not enclosed.\")\n   | Text name :: Brace_l :: rest ->\n-      let data, rest = parse_unknown rest in\n-      (match rest with\n-\tBrace_r :: rest ->\n-\t  Some (Tagged (name, data)), rest\n-      |\t_ -> failwith \"A brace is not enclosed.\")\n-  | _ -> None, l\n-\n+      let (data, rest) = parse_unknown rest\n+      in\n+        (match rest with\n+         | Brace_r :: rest -> ((Some (Tagged (name, data))), rest)\n+         | _ -> failwith \"A brace is not enclosed.\")\n+  | _ -> (None, l)\n+  \n let col_parse s =\n   let s = Utf8NF.nfd s in\n   let lexbuf = Lexing.from_string s in\n-  let ace_info = ColParser.main ColLexer.token lexbuf in\n-  cetbl_of ace_info\n-\n-let localedef = function Table tbl ->\n-  let col_info = try\n-    Some (match Hashtbl.find tbl \"CollationElements\" with \n-      Table tbl ->\n-\t(match Hashtbl.find tbl \"Sequence\" with \n-\t  String_data s -> col_parse s\n-\t| _ -> assert false)\n-    | _ -> assert false)\n-  with Not_found -> None\n-  in\n-  {Unidata.col_info = col_info}\n+  let ace_info = ColParser.main ColLexer.token lexbuf in cetbl_of ace_info\n+  \n+let localedef =\n+  function\n+  | Table tbl ->\n+      let col_info =\n+        (try\n+           Some\n+             (match Hashtbl.find tbl \"CollationElements\" with\n+              | Table tbl ->\n+                  (match Hashtbl.find tbl \"Sequence\" with\n+                   | String_data s -> col_parse s\n+                   | _ -> assert false)\n+              | _ -> assert false)\n+         with | Not_found -> None)\n+      in { Unidata.col_info = col_info; }\n   | _ -> assert false\n-\n+  \n let main () =\n   let cs = Stream.of_channel readfile in\n   let stream = CE.ustream_of enc cs in\n   let lexed = lexer stream in\n-  let data, rest = parse_table lexed [] in\n-  if rest <> [] then failwith \"Strange trailing data.\";\n-  let proc key entry =\n-    let locale_info = localedef entry in\n-    Database.write dir \"mar\" output_value key locale_info\n+  let (data, rest) = parse_table lexed []\n   in\n-  (match data with\n-    Table tbl -> Hashtbl.iter proc tbl\n-  | _ -> failwith \"Broken data.\")\n-    \n+    (if rest <> [] then failwith \"Strange trailing data.\" else ();\n+     let proc key entry =\n+       let locale_info = localedef entry\n+       in Database.write dir \"mar\" output_value key locale_info\n+     in\n+       match data with\n+       | Table tbl -> Hashtbl.iter proc tbl\n+       | _ -> failwith \"Broken data.\")\n+  \n let _ = main ()\n+  \n+\n", 
            "name": "no-camlp4.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "make install", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "camomile_enable": {
            "scope": "global", 
            "val": "enable"
          }, 
          "camomile_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "camomile_version": {
            "scope": "global", 
            "val": "0.8.5"
          }
        }
      }, 
      "dependencies": {
        "substs": "esy-ocaml/substs", 
        "@opam/ocamlfind": "*", 
        "@opam/cppo": "*", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin", 
        "@opam/camlp4": "*"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.2.3"
      }, 
      "name": "@opam/camomile"
    }, 
    "0.8.3": {
      "version": "0.8.3", 
      "opam": {
        "url": "http://prdownloads.sourceforge.net/camomile/camomile-0.8.3.tar.bz2", 
        "checksum": "c6476bdb4138d222bc14396a82205034", 
        "files": [
          {
            "content": "diff --git a/META.in b/META.in\nindex a231f19..18a8229 100644\n--- a/META.in\n+++ b/META.in\n@@ -5,4 +5,5 @@ requires=\"bigarray\"\n \n archive(byte)=\"camomile.cma\"\n archive(native)=\"camomile.cmxa\"\n+archive(native, plugin)=\"camomile.cmxs\"\n \ndiff --git a/Makefile.in b/Makefile.in\nindex 7afe20f..9dc8862 100644\n--- a/Makefile.in\n+++ b/Makefile.in\n@@ -121,7 +121,7 @@ internal/uReStrParser.cmo : internal/uReStrParser.cmi\n internal/uReStrParser.cmx : internal/uReStrParser.cmi\n \n byte : camomile.cma camomileLibrary.cma\n-opt : camomile.cmxa camomileLibrary.cmxa\n+opt : camomile.cmxa camomile.cmxs camomileLibrary.cmxa\n \n $(NOOBJ_INT:.cmi=.cmo) : %.cmo : %.mli %.cmi\n \t$(OCAMLC) -c $(BFLAGS) -impl $<\n@@ -139,6 +139,8 @@ camomile.cma : $(OBJECTS) camomileLibrary.cmo camomileLibraryDefault.cmo camomil\n \t$(OCAMLC) -a -o camomile.cma $(OBJECTS) camomileLibrary.cmo camomileLibraryDefault.cmo camomileLibraryDyn.cmo\n camomile.cmxa : $(OPTOBJECTS) camomileLibrary.cmx camomileLibraryDefault.cmx camomileLibraryDyn.cmx\n \t$(OCAMLOPT) -a -o camomile.cmxa $(OPTOBJECTS) camomileLibrary.cmx camomileLibraryDefault.cmx camomileLibraryDyn.cmx\n+camomile.cmxs : camomile.cmxa\n+\t$(OCAMLOPT) -shared -linkall -o camomile.cmxs camomile.cmxa\n \n camomileLibrary.cma : $(OBJECTS) camomileLibrary.cmo\n \t$(OCAMLC) -a -o camomileLibrary.cma $(OBJECTS) camomileLibrary.cmo\n@@ -401,6 +403,7 @@ install-without-ocamlfind:\n \tif [ -f camomileLibraryDyn.cmx ]; then cp -f camomileLibraryDyn.cmx '$(OCAMLLIB)'; fi\n \tif [ -f camomile.cma ]; then cp -f camomile.cma '$(OCAMLLIB)'; fi\n \tif [ -f camomile.cmxa ]; then cp -f camomile.cmxa '$(OCAMLLIB)'; fi\n+\tif [ -f camomile.cmxs ]; then cp -f camomile.cmxs '$(OCAMLLIB)'; fi\n \tif [ -f camomile.a ]; then cp -f camomile.a '$(OCAMLLIB)'; fi\n \n install-with-ocamlfind:\n@@ -412,6 +415,7 @@ install-with-ocamlfind:\n \tif [ -f camomileLibraryDyn.cmx ]; then files=\"camomileLibraryDyn.cmx $$files\"; fi && \\\n \tif [ -f camomile.cma ]; then files=\"camomile.cma $$files\"; fi&& \\\n \tif [ -f camomile.cmxa ]; then files=\"camomile.cmxa $$files\"; fi&& \\\n+\tif [ -f camomile.cmxs ]; then files=\"camomile.cmxs $$files\"; fi&& \\\n \tif [ -f camomile.a ]; then files=\"camomile.a $$files\"; fi && \\\n \tocamlfind install camomile $$files META $(MLI) camomileLibrary.cmi camomileLibraryDefault.cmi camomileLibraryDyn.cmi\n \n@@ -508,7 +512,7 @@ tags :\n \totags */*.ml */*.mli *.ml *.mli\n \n clean :\n-\trm -f *.cm[ioxa] *.cmxa *.o *.so *.a */*.cm[iox] */*.o pocaml\\\n+\trm -f *.cm[ioxa] *.cmxa *.cmxs *.o *.so *.a */*.cm[iox] */*.o pocaml\\\n \t*/*.byte */*.opt\n \trm -f database/*.mar\n \trm -f charmaps/*.mar\n", 
            "name": "cmxs.patch"
          }
        ]
      }, 
      "esy": {
        "buildsInSource": true, 
        "build": [
          "./configure --prefix $cur__install", 
          "make", 
          "make install", 
          "(opam-installer --prefix=$cur__install || true)"
        ], 
        "exportedEnv": {
          "camomile_enable": {
            "scope": "global", 
            "val": "enable"
          }, 
          "camomile_installed": {
            "scope": "global", 
            "val": "true"
          }, 
          "camomile_version": {
            "scope": "global", 
            "val": "0.8.3"
          }
        }
      }, 
      "dependencies": {
        "substs": "esy-ocaml/substs", 
        "@opam/ocamlfind": "*", 
        "@opam/cppo": "*", 
        "opam-installer-bin": "esy-ocaml/opam-installer-bin", 
        "@opam/camlp4": "*"
      }, 
      "scripts": {}, 
      "peerDependencies": {
        "ocaml": ">= 4.2.3"
      }, 
      "name": "@opam/camomile"
    }
  }
}